% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ The \textsf{PL} package \mbox{}}}\\
\vfill

\hypersetup{pdftitle= The \textsf{PL} package }
\markright{\scriptsize \mbox{}\hfill  The \textsf{PL} package  \hfill\mbox{}}
{\Huge  Version 2.7.0 \mbox{}}\\[1cm]
{February, 2015\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Nurlan M. Sadikov \mbox{}}}\\
{\Large \textbf{ Alexey I. Korepanov \mbox{}}}\\
{\Large \textbf{ Igor G. Korepanov \mbox{}}}\\
\hypersetup{pdfauthor= Nurlan M. Sadikov ;  Alexey I. Korepanov ;  Igor G. Korepanov }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Nurlan M. Sadikov }  Email: \href{mailto://ancleCharly@gmail.com} {\texttt{ancleCharly@gmail.com}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
\index{License} {\copyright} 2000-2014 by Nurlan M. Sadykov, Igor G. Korepanov, and Alexey I.
Korepanov 

 UNKNOWNEntity(PL) is free sotware; you car redistribute it and/or modify it
under the terms of the \href{ http://www.fsf.org/licenses/gpl.html } {GNU General Public License} as published by Free Software Foundation; either version 2 of the License, or
(at any your options) any later version. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Ball complexes}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X841C96F37BA55DBD}{}
{
 Package \textsf{PL} deals with piecewise-linear manifolds. They are described combinatorially as \emph{ball complexes}. A ball complex is, simply speaking, such kind of a cell complex where all \emph{closed} cells ( = balls) are \emph{embedded}. In particular, their boundaries are genuine spheres, not crumpled/folded.
The formal definition of \textsf{PL} ball complex reads: A PL ball complex is a pair $(X, U)$, where $X$ is a compact Euclidean polyhedron and $U$ is a covering of $X$ by closed PL-balls such that the following axioms are satisfied: 
\begin{itemize}
\item  the relative interiors of balls from $U$ form a partition of $X$, 
\item  the boundary of each ball from $U$ is a union of balls from $U$.
\end{itemize}
 We also call PL ball complexes ``polytopes'', for brevity, hence prefix
``Pol'' in the names of some of our functions. 
\section{\textcolor{Chapter }{Representation of a PL ball complex}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X7A57CB8E853465BB}{}
{
 A PL ball complex is determined up to a PL homeomorphism only by the
combinatorics of adjunctions of its balls. Due to this, we represent them
combinatorially in the following way. First, we assume that all vertices in
the complex are numbered from 1 to their total number $N_0$. Hence, in this sense, the 0-skeleton of the complex is described. Next,
assuming that the $k$-skeleton is already given, which implies (in particular) the numeration of
all $k$-cells, we describe the $(k+1)$-skeleton as the list of all $(k+1)$-cells, each of which, in its turn, is the set of numbers of $k$-cells in its boundary. Then we compose the list of length $n$, where $n$ is the dimension of the complex, whose elements are lists of 1-,..., $n$-cells. Thus, a three-dimensional ball $B^3$ may be represented by the following PL ball complex with two vertices 1 and 2: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  [
    [ [1,2], [1,2] ], # two one-dimensional simplexes, each with
                      # ends 1 and 2, of which the first is referred to
                      # in the next line as 1, the second - as 2;
    [ [1,2], [1,2] ], # two disks - bigons - bounded each by
                      # one-dimensional simplexes 1 and 2;
    [ [1,2] ]         # the three-ball bounded by bigons 1 and 2
  ]
  			
\end{Verbatim}
 Actually, we add a list of vertices with their names, or numbers, or something
like that in the beginning of the above ball complex representation. For
instance, our function \texttt{ballAB}$(n)$ calls them \texttt{"A"} and \texttt{"B"}. So, our \textsf{GAP} representation of the mentioned ball in is the following record: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ballAB(3);  |
  rec( vertices := [ "A", "B" ], 
    faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ] 
   )
  			
\end{Verbatim}
 Also, other useful information may be added in this record, describing, for
instance, the \emph{symmetries} of the polytope. 

\subsection{\textcolor{Chapter }{IsPolytope}}
\logpage{[ 1, 1, 1 ]}\nobreak
\hyperdef{L}{X81EA74AA7B4B6DDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPolytope({\mdseries\slshape pol})\index{IsPolytope@\texttt{IsPolytope}}
\label{IsPolytope}
}\hfill{\scriptsize (function)}}\\


 This function checks that $pol$ satisfies the formal rules describing how our polytopes must be built. It
returns \texttt{true} if no error has been found, and \texttt{false} otherwise. 

 The formal rules are as follows: 
\begin{itemize}
\item  the presence of fields \texttt{.vertices} and \texttt{.faces}, 
\item  the absence of dead links: each cell is a list of actually existing cells
making its boundary, 
\item  also, the Euler characteristic of each cell is checked. 
\end{itemize}
 In the following example, \texttt{T2} is a two-dimensional torus. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@IsPolytope(T2);|
  true
  				
\end{Verbatim}
 As there is no algorithm for recognizing an $n$-sphere (at least, for an arbitrary $n$), the verification of whether each cell is indeed a sphere has been dropped.
This of course may lead to a mistake in the case where the data satisfies the
formal rules except that some cells are not spheres: the function will still
return \texttt{true} in this case. }

 }

 
\section{\textcolor{Chapter }{Classical invariants}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X83BE61CF795EE5CC}{}
{
 Here are functions computing some classical manifold invariants, including the
fundamental group. 

\subsection{\textcolor{Chapter }{EulerNumber}}
\logpage{[ 1, 2, 1 ]}\nobreak
\hyperdef{L}{X7F2B23508384AD56}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{EulerNumber({\mdseries\slshape pol})\index{EulerNumber@\texttt{EulerNumber}}
\label{EulerNumber}
}\hfill{\scriptsize (function)}}\\


 Computes the Euler number for a ball complex. This function is polymorphic and
can accept as its input data in the polytope format (\texttt{IsPolytope}), or a named list whose elements are the numbers of cells of all dimensions,
as is returned by the function \texttt{LengthPol}.  
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@EulerNumber(T2);|
  0
  !gapprompt@gap>| !gapinput@EulerNumber(sphereAB(4));|
  2
  !gapprompt@gap>| !gapinput@EulerNumber(sphereAB(3));|
  0
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FundGroup}}
\logpage{[ 1, 2, 2 ]}\nobreak
\hyperdef{L}{X7E2C717A7CE81114}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FundGroup({\mdseries\slshape pol})\index{FundGroup@\texttt{FundGroup}}
\label{FundGroup}
}\hfill{\scriptsize (function)}}\\


 Computes a corepresentation of the fundamental group of a given polytope. Uses \textsf{GAP}'s algorithm to simplify it. }

 }

 
\section{\textcolor{Chapter }{General information about a ball complex}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X783BE9F58414A95D}{}
{
 

\subsection{\textcolor{Chapter }{LengthPol}}
\logpage{[ 1, 3, 1 ]}\nobreak
\hyperdef{L}{X82674C6C7C537F9E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LengthPol({\mdseries\slshape pol})\index{LengthPol@\texttt{LengthPol}}
\label{LengthPol}
}\hfill{\scriptsize (function)}}\\


 Returns the following record: \texttt{LengthPol.}$d$ is the cardinality of the $d$-skeleton in polytope $pol$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LengthPol(T2);|
  total16
  rec( 0 := 4, 1 := 8, 2 := 4 )
  					  	
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolBoundary}}
\logpage{[ 1, 3, 2 ]}\nobreak
\hyperdef{L}{X7826D40B82C44A08}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolBoundary({\mdseries\slshape pol})\index{PolBoundary@\texttt{PolBoundary}}
\label{PolBoundary}
}\hfill{\scriptsize (function)}}\\


 Computes the boundary of polytope $pol$. Returns the list of boundary $(n-1)$-cells ($n$ is the dimension of $pol$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolBoundary(T2);|
  [ ]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);;|
  !gapprompt@gap>| !gapinput@d2:=ballAB(2);;|
  !gapprompt@gap>| !gapinput@ft2:=PolProduct(d2,s1);;|
  !gapprompt@gap>| !gapinput@PolBoundary(ft2);|
  [ 1, 2, 3, 4 ]
  						
\end{Verbatim}
 Here \texttt{T2} is a 2-torus, \texttt{s1} - a 1-sphere, \texttt{d2} - a 2-ball, and \texttt{ft2} - a solid torus obtained as the Cartesian product of \texttt{d2} and \texttt{s1}. }

 

\subsection{\textcolor{Chapter }{PolInnerFaces}}
\logpage{[ 1, 3, 3 ]}\nobreak
\hyperdef{L}{X7DF0C625871788B7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolInnerFaces({\mdseries\slshape pol})\index{PolInnerFaces@\texttt{PolInnerFaces}}
\label{PolInnerFaces}
}\hfill{\scriptsize (function)}}\\


 Builds the list whose $i$-th entry is the list of inner faces of polytope $pol$ of dimension $(i-1)$. Here $i$ ranges from 1 to the polytope dimension. Any face is outer if it has at most
one adjacent face of a higher  dimension, or if it lies in the boundary of an outer face. Inner faces are, of
course, the faces that are not outer. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolInnerFaces(T2);|
  [ [ 1 .. 4 ], [ 1 .. 8 ] ]
  !gapprompt@gap>| !gapinput@PolInnerFaces(ft2);|
  [ [  ], [  ], [ 5, 6 ] ]
  !gapprompt@gap>| !gapinput@PolInnerFaces(ballAB(5));|
  [ [  ], [  ], [  ], [  ], [  ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MaxTree}}
\logpage{[ 1, 3, 4 ]}\nobreak
\hyperdef{L}{X7DDF02FE8581EF3D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MaxTree({\mdseries\slshape pol})\index{MaxTree@\texttt{MaxTree}}
\label{MaxTree}
}\hfill{\scriptsize (function)}}\\


 finds a maximal tree in the 1-skeleton of a polytope as a list of edges. }

 Let cells $a$ and $b$ have dimensions $n$ and $n-1$, respectively, and let $b$ lie in the boundary of $a$. We introduce incidence numbers, or \emph{relative orientations} $\epsilon(b|a)=\pm 1$, satisfying $\epsilon(b_1|a)\epsilon(c|b_1) = -\epsilon(b_2|a)\epsilon(c|b_2),$ where cell $c$ is of dimension $n-2$ and $b_1, b_2 \subset a$, $c \subset b_1 \cap b_2$. If $a$ is an edge, then the relative orientation is negative for its vertex with the
smaller number, and positive for its vertex with the bigger number. 

\subsection{\textcolor{Chapter }{CellOrient}}
\logpage{[ 1, 3, 5 ]}\nobreak
\hyperdef{L}{X82CF2896859B26C6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CellOrient({\mdseries\slshape pol})\index{CellOrient@\texttt{CellOrient}}
\label{CellOrient}
}\hfill{\scriptsize (function)}}\\


 Computes inductively relative orientations for cells of dimensions $1..n=dim(pol)$ of polytope $pol$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@b1 := ballAB(1);|
  rec( faces := [ [ [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@square := PolProduct(b1,b1);|
  rec( 
    faces := [ [ [ 1, 2 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ] ], [ [ 1, 2, 3, 4 ] ] ],
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  !gapprompt@gap>| !gapinput@CellOrient(square);|
  [ [ [ -1, 1 ], [ -1, 1 ], [ -1, 1 ], [ -1, 1 ] ], [ [ -1, 1, 1, -1 ] ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolOrient}}
\logpage{[ 1, 3, 6 ]}\nobreak
\hyperdef{L}{X7A1EAA26847A1C43}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolOrient({\mdseries\slshape pol})\index{PolOrient@\texttt{PolOrient}}
\label{PolOrient}
}\hfill{\scriptsize (function)}}\\


 If $pol$ is orientable, gives a consistent orientation of $n$-faces ($n=\dim(pol)$), otherwise returns $fail$. }

 

\subsection{\textcolor{Chapter }{OrientTriangulated}}
\logpage{[ 1, 3, 7 ]}\nobreak
\hyperdef{L}{X81AE197083B0A56A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrientTriangulated({\mdseries\slshape pol})\index{OrientTriangulated@\texttt{OrientTriangulated}}
\label{OrientTriangulated}
}\hfill{\scriptsize (function)}}\\


 Function computes a consistent orientation for the simplices of the greatest
dimension of a given \emph{triangulated} complex $pol$. Returns array of $-1, 1$-s corresponding to the orientation of simplices of greatest dimension of $pol$. }

 

\subsection{\textcolor{Chapter }{dataPachner}}
\logpage{[ 1, 3, 8 ]}\nobreak
\hyperdef{L}{X83986ED47DDF8E20}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{dataPachner({\mdseries\slshape dim, k})\index{dataPachner@\texttt{dataPachner}}
\label{dataPachner}
}\hfill{\scriptsize (function)}}\\


 Returns the description of the Pachner move in dimension $dim$, whose initial configuration, or \emph{left-hand side} (l.h.s.), consists of $k$ simplices (hence, the final configuration, or \emph{right-hand side} (r.h.s.), consists of $dim-k+2$ simplices). The description is returned in the form of a record, where \texttt{.l} describes the polytope (cluster of simplices) in the l.h.s., while \texttt{.r} describes the polytope in the r.h.s. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Print(dataPachner(3,2));|
  rec(
    l := rec(
        pol := rec(
            faces :=
             [
                [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ],
                    [ 1, 5 ], [ 2, 5 ], [ 3, 5 ] ],
                [ [ 1, 4, 5 ], [ 1, 7, 8 ], [ 2, 4, 6 ], [ 2, 7, 9 ],
                    [ 3, 5, 6 ], [ 3, 8, 9 ], [ 1, 2, 3 ] ],
                [ [ 1, 3, 5, 7 ], [ 2, 4, 6, 7 ] ] ],
            vertices := [ 1, 2, 3, 4, 5 ] ),
        sim := [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ] ],
        vnut := [ 7 ] ),
    r := rec(
        pol := rec(
            faces :=
             [
                [ [ 1, 2 ], [ 1, 4 ], [ 2, 4 ], [ 1, 5 ], [ 2, 5 ], [ 4, 5 ],
                    [ 1, 3 ], [ 3, 4 ], [ 3, 5 ], [ 2, 3 ] ],
                [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 7, 8 ], [ 4, 7, 9 ],
                    [ 3, 8, 10 ], [ 5, 9, 10 ], [ 2, 4, 6 ], [ 3, 5, 6 ],
                    [ 6, 8, 9 ] ],
                [ [ 1, 2, 7, 8 ], [ 3, 4, 7, 9 ], [ 5, 6, 8, 9 ] ] ],
            vertices := [ 1, 2, 3, 4, 5 ] ),
        sim := [ [ 1, 2, 4, 5 ], [ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ],
        vnut := [ 7, 8, 9 ] ) )
    						
\end{Verbatim}
 Both \texttt{.l} and \texttt{.r} are, in their turn, also records. Each of them contains an entry \texttt{.pol} representing the corresponding polytope in the form of a triangulated ball
complex, an entry \texttt{.sim} representing the same polytope as a list of $dim$-simplices each given \emph{as the list of its vertices}, and an entry \texttt{.vnut} - the list of the (numbers of the) \emph{inner} $(n-1)$-cells. }

 Simplicial complex are often understood in a restricted sense, namely, it is
requried that no two simplices have the same sets of vertices. In this case, a
simplicial complex can be given in the form of a list of simplices, each of
those specified by the list of its vertices. For an $n$-dimensional manifold with boundary, it is enough to list just its $n$-simplices. For instance, the boundary of 4-simplex 12345 can be written as 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sim := [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 5 ], [ 1, 2, 4, 5 ],|
  				[ 1, 3, 4, 5 ], [ 2, 3, 4, 5 ] ];
  				
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{FromSimplexToPolytope}}
\logpage{[ 1, 3, 9 ]}\nobreak
\hyperdef{L}{X873915C482448F75}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FromSimplexToPolytope({\mdseries\slshape sim})\index{FromSimplexToPolytope@\texttt{FromSimplexToPolytope}}
\label{FromSimplexToPolytope}
}\hfill{\scriptsize (function)}}\\


 turns a list $sim$ of simplices into a ball complex. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@FromSimplexToPolytope(sim);|
  rec(
    faces :=
      [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ],
            [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ],
        [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 2, 4, 6 ], [ 3, 5, 6 ], [ 1, 7, 8 ],
            [ 2, 7, 9 ], [ 3, 8, 9 ], [ 4, 7, 10 ], [ 5, 8, 10 ], [ 6, 9, 10 ] ]
          , [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 2, 5, 8, 9 ], [ 3, 6, 8, 10 ],
            [ 4, 7, 9, 10 ] ] ], vertices := [ 1, 2, 3, 4, 5 ] )
  						
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Working with cells}}\logpage{[ 1, 4, 0 ]}
\hyperdef{L}{X84F6B7837CCA4EAE}{}
{
 In this Section, we describe the functions providing information about a cell
in a triangulation of a PL manifold. The cell is determined by the pair of
numbers $[dim,ind]$, where $dim$ is its dimension, and $ind$ - its position in the list \texttt{pol.faces[}$dim$\texttt{]}. Such a pair will be called below the \emph{address} of the cell, or simply "cell", and denoted $adr=[dim,ind]$. 

\subsection{\textcolor{Chapter }{PolBnd}}
\logpage{[ 1, 4, 1 ]}\nobreak
\hyperdef{L}{X7AB8BF4E7E72C22D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolBnd({\mdseries\slshape pol, adr})\index{PolBnd@\texttt{PolBnd}}
\label{PolBnd}
}\hfill{\scriptsize (function)}}\\


 Creating an index of boundary faces of face $adr=[dim,ind]$ of complex $pol$ in the form of a list. Its $i$'th entry is the list of $(i-1)$-dimensional faces of $pol$ which are in the boundary of $adr$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolBnd(T2,[2,3]);|
  [ [ 1, 2, 3, 4 ], [ 2, 4, 5, 7 ] ]
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FaceComp}}
\logpage{[ 1, 4, 2 ]}\nobreak
\hyperdef{L}{X7B4C20C784524379}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FaceComp({\mdseries\slshape pol, adr})\index{FaceComp@\texttt{FaceComp}}
\label{FaceComp}
}\hfill{\scriptsize (function)}}\\


 A function similar to \texttt{PolBnd}, but the output is in the form of a record with entries $.d$, where $d$ is the cell dimension. Also, the input cell is included. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@FaceComp(T2,[2,3]);|
  rec( 0 := [ 1, 2, 3, 4 ], 1 := [ 2, 4, 5, 7 ], 2 := [ 3 ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StarFace}}
\logpage{[ 1, 4, 3 ]}\nobreak
\hyperdef{L}{X7E4697E984788243}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StarFace({\mdseries\slshape pol, adr})\index{StarFace@\texttt{StarFace}}
\label{StarFace}
}\hfill{\scriptsize (function)}}\\


 Computes the star of cell $adr$, that is, all cells of higher dimensions containing $adr$, in the ball complex $pol$, in the form of a record. The entry $.i$ contains the numbers of $i$-cells contained in the star. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@StarFace(T2,[0,3]);|
  rec( 1 := [ 2, 3, 6, 7 ], 2 := [ 1, 2, 3, 4 ] )
  						
\end{Verbatim}
 In this example, 1-cells indexed 2, 3, 6 and 7, and 2-cells indexed 1, 2, 3
and 4, form the star of vertex no. 3 of the ball complex \texttt{T2}. }

 

\subsection{\textcolor{Chapter }{PolCheckComb}}
\logpage{[ 1, 4, 4 ]}\nobreak
\hyperdef{L}{X7BBC530C857D247E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolCheckComb({\mdseries\slshape pol, adr})\index{PolCheckComb@\texttt{PolCheckComb}}
\label{PolCheckComb}
}\hfill{\scriptsize (function)}}\\


 Checks whether face $adr$ of ball complex $pol$ is "strictly combinatorial", that is, whether every its subface of lower
dimension is uniquely determined by its vertices (and dimension). }

 }

 
\section{\textcolor{Chapter }{Changing the ball complex representation of the same manifold }}\logpage{[ 1, 5, 0 ]}
\hyperdef{L}{X856D417E845781C9}{}
{
 

\subsection{\textcolor{Chapter }{PolTriangulate}}
\logpage{[ 1, 5, 1 ]}\nobreak
\hyperdef{L}{X79EBAEC68713D5FE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolTriangulate({\mdseries\slshape pol})\index{PolTriangulate@\texttt{PolTriangulate}}
\label{PolTriangulate}
}\hfill{\scriptsize (function)}}\\


 Triangulates polytope $pol$. Triangulation is understood in a broader sense, as a ball complex made only
of simplices, but a simplex may \emph{not} be determined by its boundary (not to say its vertices). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolTriangulate(sphereAB(2));|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
        [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
    vertices := [ "A", "B", "V1", "V2" ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolCanonicalOrder}}
\logpage{[ 1, 5, 2 ]}\nobreak
\hyperdef{L}{X82D5FE8884324786}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolCanonicalOrder({\mdseries\slshape pol})\index{PolCanonicalOrder@\texttt{PolCanonicalOrder}}
\label{PolCanonicalOrder}
}\hfill{\scriptsize (function)}}\\


 Produces the canonical order of cells in a triangulated polytope. The
canonical order is the lexicographical order of cells when these are
represented by their vertices. }

 

\subsection{\textcolor{Chapter }{FirstBoundary}}
\logpage{[ 1, 5, 3 ]}\nobreak
\hyperdef{L}{X7DE97F0184E8F0BE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FirstBoundary({\mdseries\slshape pol})\index{FirstBoundary@\texttt{FirstBoundary}}
\label{FirstBoundary}
}\hfill{\scriptsize (function)}}\\


 Changes the order of polytope $pol$ cells in such way that the boundary cells go first in the lists $pol$\texttt{.faces[}$dim$\texttt{]}. The order of cells within the boundary remains unchanged. }

 

\subsection{\textcolor{Chapter }{PermFaces}}
\logpage{[ 1, 5, 4 ]}\nobreak
\hyperdef{L}{X863CAD14822179DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PermFaces({\mdseries\slshape pol, perm, dim})\index{PermFaces@\texttt{PermFaces}}
\label{PermFaces}
}\hfill{\scriptsize (function)}}\\


 Re-orders of $dim$-cells in polytope $pol$ according to permutation $perm$. Important note: works correctly on $pol$\texttt{.vertices} ($dim=0$) and $pol$\texttt{.faces}, but \emph{ignores} additional entries (if any), such as symmetries ($pol$\texttt{.syms}). }

 We call a$d$-cell in a ball complex \emph{minimal} if its boundary consists of only two $(d - 1)$-cells. 

\subsection{\textcolor{Chapter }{ContractMiniFace}}
\logpage{[ 1, 5, 5 ]}\nobreak
\hyperdef{L}{X844FBAF17BC1B42B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ContractMiniFace({\mdseries\slshape pol, adr})\index{ContractMiniFace@\texttt{ContractMiniFace}}
\label{ContractMiniFace}
}\hfill{\scriptsize (function)}}\\


 Collapses minimal cell $adr$ in polytope $pol$. That is, withdraws $adr$ from the complex, and its two boundary cells (of dimension less by 1 than $adr$) are, accordingly, glued together into one cell. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1:=sphereTriangul(1); # triangulated sphere of dimension 1|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
  !gapprompt@gap>| !gapinput@s1:=ContractMiniFace(s1,[1,1]);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ 1, 3 ] )
  						
\end{Verbatim}
 In some cases, the result of collapsing a minimal cell may \emph{not} be a ball complex. This function does not check this, this is left to the
user! For instance, if we try to collapse one more edge in the above circle $s1$, we get 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1:=ContractMiniFace(s1,[1,1]);|
  rec( faces := [ [ [ 1 ] ] ], vertices := [ 1 ] )
  !gapprompt@gap>| !gapinput@IsPolytope(s1);|
  false
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DivideFace}}
\logpage{[ 1, 5, 6 ]}\nobreak
\hyperdef{L}{X7AF2A3E286F2E10F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DivideFace({\mdseries\slshape pol, adr, set})\index{DivideFace@\texttt{DivideFace}}
\label{DivideFace}
}\hfill{\scriptsize (function)}}\\


 Let there be a cell $adr$ of dimension $d=adr[1]$ in ball complex $pol$, and let $set$ be a set (in the GAP sense) of cells that lie in the boundary of cell $adr$, and form together a $(d-2)$-sphere $S^{d-2}$. 

 The function breaks the cell $adr$ into two parts by spanning a disk $D^{d-1}$ over $S^{d-2}$ and inside cell $adr$. 

 Warning: the function does \emph{not} check whether $set$ really makes a sphere in the boundary of $adr$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@octahedron;|
  rec(
    faces :=
  	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ], 
    		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
  	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ],
  	  	[ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ] ], [ [ 1 .. 8 ] ] ], 
  	vertices := [ 1 .. 6 ] )
  !gapprompt@gap>| !gapinput@DivideFace(octahedron,[3,1],[1,2,3,4]);|
  rec(
    faces :=
   	[ [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 4 ], [ 1, 5 ], [ 2, 5 ], [ 3, 5 ],
    		[ 4, 5 ], [ 1, 6 ], [ 2, 6 ], [ 3, 6 ], [ 4, 6 ] ],
  	  [ [ 1, 5, 6 ], [ 2, 6, 7 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 1, 9, 10 ], 
  	    [ 2, 10, 11 ], [ 3, 11, 12 ], [ 4, 9, 12 ], [ 1, 2, 3, 4 ] ],
  	  [ [ 1, 4, 2, 3, 9 ], [ 5, 6, 7, 8, 9 ] ] ], 
  		vertices := [ 1 .. 6 ] )
  						
\end{Verbatim}
 There is also a special case where a 1-cell $adr$ is divided, by adding a vertex in its middle. In this case, the name of this
new vertex is indicated instead of the set $set$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@DivideFace(s1,[1,1],3);|
  rec( faces := [ [ [ 1, 3 ], [ 1, 2 ], [ 2, 3 ] ] ], vertices := [ "A", "B", 3 ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{UnionFaces}}
\logpage{[ 1, 5, 7 ]}\nobreak
\hyperdef{L}{X81F8A08386AC2C68}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnionFaces({\mdseries\slshape pol, cell1, cell2})\index{UnionFaces@\texttt{UnionFaces}}
\label{UnionFaces}
}\hfill{\scriptsize (function)}}\\


 The input is ball compex $pol$ and two cells $cell1$ and $cell2$ of the same dimension, whose intersection - the \emph{partition} between them - is just one (closed) cell of dimension less by one. The
function unites these cells into one and deletes the partition cell. The
details are as follows. 

 First, we assume that $pol$ is a correctly defined ball complex. Then, the function checks that the
intersection of $cell1$ and $cell2$ is indeed exactly one closed cell, as described above. This implies, of
course, the checking of \emph{all} cells of \emph{all} dimensions less than that of $cell1$ and $cell2$. 

 Moreover, one more check is performed within the \emph{star} (see \texttt{StarFace}) of the partition being deleted: the absence of dead links after the
deletion. Namely, the partition cell must not enter in the boundary of any \emph{other} cell of the same dimension as $cell1$ and $cell2$. 

 If the result of any of these checks is negative, then the function returns
the \emph{initial} polytope. ****What is "p3" below?**** 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@p3 := dataPachner(3,3).l.pol; # this gives a cluster of 3 tetrahedra |
                                     # around an edge, as in the l.h.s.
                                     # of Pachner move 3-2
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ], 
            [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ], 
        [ [ 2, 4, 6 ], [ 2, 7, 9 ], [ 4, 7, 10 ], [ 3, 5, 6 ], [ 3, 8, 9 ], 
            [ 5, 8, 10 ], [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 7, 8 ] ], 
        [ [ 1, 4, 7, 8 ], [ 2, 5, 7, 9 ], [ 3, 6, 8, 9 ] ] ], 
    vertices := [ 1, 2, 3, 4, 5 ] )
  !gapprompt@gap>| !gapinput@IsPolytope(p3);|
  true
  !gapprompt@gap>| !gapinput@p3 := UnionFaces(p3,[3,1],[3,2]); # in the new p3, the first two|
                                         # tetrahedra are united into one cell
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ], [ 3, 4 ], [ 1, 5 ], 
            [ 2, 5 ], [ 3, 5 ], [ 4, 5 ] ], 
        [ [ 2, 4, 6 ], [ 2, 7, 9 ], [ 4, 7, 10 ], [ 3, 5, 6 ], [ 3, 8, 9 ], 
            [ 5, 8, 10 ], [ 1, 4, 5 ], [ 1, 7, 8 ] ], 
        [ [ 1, 2, 4, 5, 7, 8 ], [ 3, 6, 7, 8 ] ] ], 
    vertices := [ 1, 2, 3, 4, 5 ] )
  !gapprompt@gap>| !gapinput@IsPolytope(p3);|
  true
  						
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@UnionFaces(T2,[2,1],[2,3]) = T2;   # T2 is a 2-torus made of four squares|
  true
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PolSimplify}}
\logpage{[ 1, 5, 8 ]}\nobreak
\hyperdef{L}{X784F04327D5BD9A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolSimplify({\mdseries\slshape pol})\index{PolSimplify@\texttt{PolSimplify}}
\label{PolSimplify}
}\hfill{\scriptsize (function)}}\\


 Simplifies polytope $pol$ using \texttt{UnionFaces}. The function searches through all possibilities, starting from the cells of
the maximal dimension. Note, however, that, after applying this function, new
possibilities may occur. So, the function can be applied several times, in
order to simplify the polytope as far as possible. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@a:=ballTriangul(3); # triangulated 3-ball (tetrahedron)|
  rec( 
    faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ], 
        [ [ 1, 2, 4 ], [ 1, 3, 5 ], [ 2, 3, 6 ], [ 4, 5, 6 ] ], [ [ 1 .. 4 ] ] ]
      , vertices := [ 1 .. 4 ] )
  !gapprompt@gap>| !gapinput@PolSimplify(a);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ]
      , vertices := [ 1, 2 ] )
  						
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Topological operations}}\logpage{[ 1, 6, 0 ]}
\hyperdef{L}{X84A34BC282FD8BF3}{}
{
 

\subsection{\textcolor{Chapter }{FreeUnionPol}}
\logpage{[ 1, 6, 1 ]}\nobreak
\hyperdef{L}{X833B125E832EA5F5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FreeUnionPol({\mdseries\slshape pol1, pol2})\index{FreeUnionPol@\texttt{FreeUnionPol}}
\label{FreeUnionPol}
}\hfill{\scriptsize (function)}}\\


 Free union of polytopes 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@FreeUnionPol(s1,s1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ] ] ],
    vertices := [ [ 1, "A" ], [ 1, "B" ], [ 2, "A" ], [ 2, "B" ] ] )
  						
\end{Verbatim}
 The free union is performed by concatenating the lists of faces. The indices
(numbers) of faces belonging to the second polytope are shifted - increased by
the number of corresponding faces in the first polytope. }

 

\subsection{\textcolor{Chapter }{PolDoubleCone}}
\logpage{[ 1, 6, 2 ]}\nobreak
\hyperdef{L}{X813B0AA1829E736E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolDoubleCone({\mdseries\slshape pol})\index{PolDoubleCone@\texttt{PolDoubleCone}}
\label{PolDoubleCone}
}\hfill{\scriptsize (function)}}\\


 Makes a double cone with vertices V1 and V2 over the given polytope $pol$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolDoubleCone(s1);|
  rec(
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 4 ], [ 2, 4 ] ],
        [ [ 1, 3, 4 ], [ 2, 3, 4 ], [ 1, 5, 6 ], [ 2, 5, 6 ] ] ],
    vertices := [ "A", "B", "V1", "V2" ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ConnectedSum}}
\logpage{[ 1, 6, 3 ]}\nobreak
\hyperdef{L}{X7F680736784EA2B0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConnectedSum({\mdseries\slshape N, M})\index{ConnectedSum@\texttt{ConnectedSum}}
\label{ConnectedSum}
}\hfill{\scriptsize (function)}}\\


 Makes a connected sum of two polytopes $N$ and $M$ of the same dimension. 

 Currently, the function does not take care of orientations. An improved
function is expected to appear in this package, where the result will depend
on the orientations prescribed by the user. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s2 := sphereAB(2);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ] ], 
    vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@s2s2 := ConnectedSum(s2,s2);|
  rec( 
    faces := [ [ [ 1, 2 ], [ 1, 2 ], [ 1, 2 ], [ 1, 2 ] ], 
        [ [ 1, 3 ], [ 1, 2 ], [ 3, 4 ], [ 2, 4 ] ] ], 
    vertices := [ [ 1, "A" ], [ 1, "B" ] ] )
  !gapprompt@gap>| !gapinput@s2s2 := PolSimplify(s2s2);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ] ], 
    vertices := [ [ 1, "A" ], [ 1, "B" ] ] )
  						
\end{Verbatim}
 We see also that here \texttt{PolSimplify} returns essentially the same \texttt{s2} from which we started. }

 

\subsection{\textcolor{Chapter }{PolProduct}}
\logpage{[ 1, 6, 4 ]}\nobreak
\hyperdef{L}{X7A9E18837F637D8D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProduct({\mdseries\slshape pol1, pol2})\index{PolProduct@\texttt{PolProduct}}
\label{PolProduct}
}\hfill{\scriptsize (function)}}\\


 Calculates the Cartesian product of two ball complexes $pol1$ and $pol2$. This is the ball complex made of all balls $D^s_i \times D^t_j$, where $D^s_i$ and $D^t_j$ are cells in $M$ and $N$, respectively. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PolProduct(s1,s1);|
  rec(
    faces :=
      [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ],
            [ 2, 4 ] ],
        [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ],
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  						
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ImageInPolProduct}}
\logpage{[ 1, 6, 5 ]}\nobreak
\hyperdef{L}{X7F0929CD82A0CE28}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ImageInPolProduct({\mdseries\slshape pol1, pol2, cells})\index{ImageInPolProduct@\texttt{ImageInPolProduct}}
\label{ImageInPolProduct}
}\hfill{\scriptsize (function)}}\\


 Auxiliary function for calculating the Cartesian product of polytopes $pol1$ and $pol2$. The last argument $cells$ is the list of two cells $kl1$ and $kl2$ belonging to these two respective polytopes. Computes the address of cell $kl1 \times kl2$ in the mentioned Cartesian product. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@ImageInPolProduct(s1,s1,[[1,2],[1,1]]);|
  [ 2, 3 ]
  						
\end{Verbatim}
 One more possibility for the input is named lists instead of polytopes $pol1$ and $pol2$. In these, to each dimension $k$ corresponds the cardinality of the set of $k$-cells. This possibility helps if the function is frequently called for one
and the same Cartesian product. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ls1:=rec(0:=2, 1:=2);|
  rec( 0 := 2, 1 := 2 )
  !gapprompt@gap>| !gapinput@ImageInPolProduct(ls1,ls1,[[1,2],[1,1]]);|
  [ 2, 3 ]
  						
\end{Verbatim}
 Note that the function is valid only for the complex obtained by \texttt{PolProduct}. If the complex has changed somehow, the address may become incorrect. }

 

\subsection{\textcolor{Chapter }{PreimageInPolProduct}}
\logpage{[ 1, 6, 6 ]}\nobreak
\hyperdef{L}{X7C2DFBEA78356D9D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PreimageInPolProduct({\mdseries\slshape pol1, pol2, imageface})\index{PreimageInPolProduct@\texttt{PreimageInPolProduct}}
\label{PreimageInPolProduct}
}\hfill{\scriptsize (function)}}\\


 For a given cell $imageface$ in the Cartesian product of polytopes $pol1$ and $pol2$, returns the list of two cells whose Cartesian product is $imageface$. The Cartesian product is of course made according to \texttt{PolProduct}. }

  

\subsection{\textcolor{Chapter }{PolProductSyms}}
\logpage{[ 1, 6, 7 ]}\nobreak
\hyperdef{L}{X7A32AE2D8733963A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProductSyms({\mdseries\slshape })\index{PolProductSyms@\texttt{PolProductSyms}}
\label{PolProductSyms}
}\hfill{\scriptsize (function)}}\\


 Cartesian product of two polytopes with symmetries of multipliers transferred
to it. First go the symmetries of the first multiplier, then - the second. }

 

\subsection{\textcolor{Chapter }{PolProductSymsDict}}
\logpage{[ 1, 6, 8 ]}\nobreak
\hyperdef{L}{X7B4164647D6C5EC6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolProductSymsDict({\mdseries\slshape })\index{PolProductSymsDict@\texttt{PolProductSymsDict}}
\label{PolProductSymsDict}
}\hfill{\scriptsize (function)}}\\


 Cartesian product of two polytopes with symmetries of multipliers transferred
to it. First go the symmetries of the first multiplier, then - the second.
Also returns the face dictionary. }

 

\subsection{\textcolor{Chapter }{PolFactorInvolution}}
\logpage{[ 1, 6, 9 ]}\nobreak
\hyperdef{L}{X7A3091A38613DA64}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolFactorInvolution({\mdseries\slshape pol, invol})\index{PolFactorInvolution@\texttt{PolFactorInvolution}}
\label{PolFactorInvolution}
}\hfill{\scriptsize (function)}}\\


 $pol$ is a polytope with symmetries, $invol$ is such a list of some of its symmetries (repetitions possible) that it is
known that the product of symmetries in $invol$ is an involution. Returns the factored polytope. 

 The function is used in \texttt{KummerSurface()}. }

 }

 
\section{\textcolor{Chapter }{Main principles of ball complex re-buildings}}\logpage{[ 1, 7, 0 ]}
\hyperdef{L}{X8075B08079BDE7F4}{}
{
 Here, we expalin the main principles of ball complex re-buildings that are
related to the change of cell indexation (numbers of cells in the lists).
Change of cell indexation is one of the main difficulties for writing our
programs in a fast and easy way. In the second version of package \textsf{PL}, we used the following idea. As far as it is feasible, the addresses of cells
not taking part in an operation must remain unchanged. This is, however, not
always possible. For instance, this is impossible if a cell is removed from a
polytope. If shifting indices cannot be avoided, then we must try to change
the minimal amount of indices. The fact that all the polytope construction is
based upon the cell numbers in the lists $pol$\texttt{.faces[}$k$\texttt{]}, complicates the work related to complex re-buildings. Starting from the
third version of package \textsf{PL}, a possibility will be implemented for a rigid cell indexation, where the
position of a cell in $pol$\texttt{.faces[}$k$\texttt{]} will be also the name of this cell. This will mean, in particular, that empty
entries may appear in the lists $pol$\texttt{.faces[}$k$\texttt{]}. At this moment, there are the following functions that permit to change the
polytope structure and attached information. 

\subsection{\textcolor{Chapter }{DelFace}}
\logpage{[ 1, 7, 1 ]}\nobreak
\hyperdef{L}{X7F4B33CD85588148}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DelFace({\mdseries\slshape pol, adr})\index{DelFace@\texttt{DelFace}}
\label{DelFace}
}\hfill{\scriptsize (function)}}\\


 Cell $adr$ is removed from polytope $pol$. Note that the result may is not guaranteed to be a correct polytope: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1 := sphereAB(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@t2 := PolProduct(s1,s1);|
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], 
            [ 2, 4 ] ], 
        [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ], 
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  !gapprompt@gap>| !gapinput@pol := DelFace(t2,[1,2]);|
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], [ 2, 4 ] ]
          , [ [ 1, 2, 4, 5 ], [ 3, 4, 5 ], [ 1, 2, 6, 7 ], [ 3, 6, 7 ] ] ], 
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  !gapprompt@gap>| !gapinput@IsPolytope(pol);|
  false
  					
\end{Verbatim}
 This function contains the most frequently used code that permits to remove
all mentionings of the given cell and prepare the data for the further work of
the algorithm. Namely, it does the following: 
\begin{itemize}
\item the cell $adr = [d, k]$ is removed,
\item references to this cell are removed,
\item the indexation of $d$-cells is changed,
\item accordingly, the references to $d$-cells in $(d+1)$-cells are changed.
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{wasDelFace}}
\logpage{[ 1, 7, 2 ]}\nobreak
\hyperdef{L}{X8371078A7CD87B96}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{wasDelFace({\mdseries\slshape pol, adr})\index{wasDelFace@\texttt{wasDelFace}}
\label{wasDelFace}
}\hfill{\scriptsize (function)}}\\


 Corrects the information attached to polytope $pol$ that may have changed after removing cell $adr$. The indices of the cells of the same dimension as $adr$ and that go after $adr$ must be decreased by 1. 

 Currently, this function works only for the information defining a 2-knot in a
polytope. Namely, in the case if a 2-cell is removed, the relevant message
will be displayed, the index of the 2-cell will be removed from the list \texttt{.2knot.sheets} and, if there is a reference to this 2-cell in \texttt{.2knot.dpoints.(}$1kl$\texttt{)}, then the corresponding position will be cleared. }

 In order to simplify polytope re-buildings, we will stick to the following
principle in the following releases of \textsf{PL}. The index of a $k$-cell in the list \texttt{pol.faces[}$k$\texttt{]} is simultaneously its identifier. This will allow us to create lists
(skeletons) \texttt{pol.faces[}$k$\texttt{]} with empty positions. If a cell is removed from a skeleton, the corresponding
position in \texttt{pol.faces[}$k$\texttt{]} is emptied. This will alow us to simplify the calculations related to the
re-enumerating of cells. This principle will be supported starting from the
third version of Package \textsf{PL}. Starting from the fourth version, \emph{only} this way of re-building will be supported. }

 
\section{\textcolor{Chapter }{The library of polytopes}}\logpage{[ 1, 8, 0 ]}
\hyperdef{L}{X81281B4283BA7F71}{}
{
 Here we list some ball complex realizations of "standard" manifolds. There are
the following functions for the disks and spheres of a given dimension. 

\subsection{\textcolor{Chapter }{ballAB}}
\logpage{[ 1, 8, 1 ]}\nobreak
\hyperdef{L}{X83EC07DE83EC07DE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ballAB({\mdseries\slshape dim})\index{ballAB@\texttt{ballAB}}
\label{ballAB}
}\hfill{\scriptsize (function)}}\\


 Creates the minimal ball complex decomposition of a $dim$-ball, with just two vertices "A" and "B". 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ballAB(3);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ] ] ]
      , vertices := [ "A", "B" ] )
                      
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{sphereAB}}
\logpage{[ 1, 8, 2 ]}\nobreak
\hyperdef{L}{X791C9DFE87250DEF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{sphereAB({\mdseries\slshape dim})\index{sphereAB@\texttt{sphereAB}}
\label{sphereAB}
}\hfill{\scriptsize (function)}}\\


 Creates the minimal ball complex decomposition of a $dim$-sphere, with just two vertices "A" and "B". 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sphereAB(3);|
  rec(
  faces := [ [ [ 1, 2 ], [ 1, 2 ] ], [ [ 1, 2 ], [ 1, 2 ] ],
    [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
                      
\end{Verbatim}
 }

 There are also \emph{triangulated} balls and spheres. 

\subsection{\textcolor{Chapter }{ballTriangul}}
\logpage{[ 1, 8, 3 ]}\nobreak
\hyperdef{L}{X82DB526A7F364516}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ballTriangul({\mdseries\slshape dim})\index{ballTriangul@\texttt{ballTriangul}}
\label{ballTriangul}
}\hfill{\scriptsize (function)}}\\


 Creates a simplex of dimension $dim$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ballTriangul(2);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ], [ [ 1 .. 3 ] ] ],
  vertices := [ 1 .. 3 ] )
                      
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{sphereTriangul}}
\logpage{[ 1, 8, 4 ]}\nobreak
\hyperdef{L}{X80EEACD2781E40F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{sphereTriangul({\mdseries\slshape dim})\index{sphereTriangul@\texttt{sphereTriangul}}
\label{sphereTriangul}
}\hfill{\scriptsize (function)}}\\


 Creates a triangulated sphere in the form of the boundary of a $(dim+1)$simplex. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@sphereTriangul(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ] ] ], vertices := [ 1 .. 3 ] )
                      
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{projectivePlane}}
\logpage{[ 1, 8, 5 ]}\nobreak
\hyperdef{L}{X87EEC49B7E1457D8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{projectivePlane({\mdseries\slshape dim})\index{projectivePlane@\texttt{projectivePlane}}
\label{projectivePlane}
}\hfill{\scriptsize (function)}}\\


 Real projective space of dimension $dim$ }

 

\subsection{\textcolor{Chapter }{s2s2twisted}}
\logpage{[ 1, 8, 6 ]}\nobreak
\hyperdef{L}{X85AAD06F7C9492C8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{s2s2twisted\index{s2s2twisted@\texttt{s2s2twisted}}
\label{s2s2twisted}
}\hfill{\scriptsize (global variable)}}\\


 Twisted product of two spheres $S^2$ }

 

\subsection{\textcolor{Chapter }{cp2}}
\logpage{[ 1, 8, 7 ]}\nobreak
\hyperdef{L}{X83ACE6A984BDC4F7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{cp2\index{cp2@\texttt{cp2}}
\label{cp2}
}\hfill{\scriptsize (global variable)}}\\


 Complex projective plane }

 

\subsection{\textcolor{Chapter }{PoincareSphere}}
\logpage{[ 1, 8, 8 ]}\nobreak
\hyperdef{L}{X847517A37F6E2C3B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PoincareSphere\index{PoincareSphere@\texttt{PoincareSphere}}
\label{PoincareSphere}
}\hfill{\scriptsize (global variable)}}\\


 Poincare sphere }

 

\subsection{\textcolor{Chapter }{TorTwist}}
\logpage{[ 1, 8, 9 ]}\nobreak
\hyperdef{L}{X847B369C82DCDA9D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TorTwist({\mdseries\slshape n})\index{TorTwist@\texttt{TorTwist}}
\label{TorTwist}
}\hfill{\scriptsize (function)}}\\


 Twisted 3-torus - the torus bundle over $S^1$, with the monodromy matrix \texttt{ [ [ 1, -n ], [ 0, 1 ]} The algorithm works for \emph{natural} $n=1,2,3,\ldots$. }

 

\subsection{\textcolor{Chapter }{KummerSurface}}
\logpage{[ 1, 8, 10 ]}\nobreak
\hyperdef{L}{X7BB7FEDB878DC7B1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KummerSurface({\mdseries\slshape })\index{KummerSurface@\texttt{KummerSurface}}
\label{KummerSurface}
}\hfill{\scriptsize (function)}}\\


 Creates the Kummer surface, with singularities resolved - i.e., a true
4-manifold. }

 

\subsection{\textcolor{Chapter }{Lens}}
\logpage{[ 1, 8, 11 ]}\nobreak
\hyperdef{L}{X783B77F17E964030}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Lens({\mdseries\slshape n, k})\index{Lens@\texttt{Lens}}
\label{Lens}
}\hfill{\scriptsize (function)}}\\


 Three-dimensional lens space $L(n,k)$. }

 }

 }

 
\chapter{\textcolor{Chapter }{Subpolytopes and embeddings}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7D9643C07CB9C138}{}
{
 Subpolytope $subpol$ will be understood as a set of cells of a given dimension $k$ if the union of these cells (cells are understood as \emph{closed}) forms a PL submanifold $N \subset M$. The simplest example of a subpolytope is a disk represented as the list of
just one element of any dimension of a polytope $pol$. We will not, however, define subpolytope as any rigid construction. It will
be clear from the context what we mean each time. 
\section{\textcolor{Chapter }{Subpolytopes, boundaries, gluing, removing neighborhoods...}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7AC0866A80BD94BD}{}
{
 

\subsection{\textcolor{Chapter }{SetOfFacesBoundary}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X846E72167C7779D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SetOfFacesBoundary({\mdseries\slshape pol, subpol, dim})\index{SetOfFacesBoundary@\texttt{SetOfFacesBoundary}}
\label{SetOfFacesBoundary}
}\hfill{\scriptsize (function)}}\\


 Returns the boundary of subpolytope $subpol$ of dimension $dim$ of polytope $pol$. To be exact, $subpol$ here is a list of some $dim$-cells in $pol$. The returned boundary is, accordingly, a list of $(dim-1)$-cells. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1 := sphereAB(1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ], vertices := [ "A", "B" ] )
  !gapprompt@gap>| !gapinput@t2 := PolProduct(s1,s1);|
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 1, 2 ], [ 3, 4 ], [ 3, 4 ], [ 1, 3 ], [ 2, 4 ], [ 1, 3 ], 
            [ 2, 4 ] ], 
        [ [ 1, 3, 5, 6 ], [ 2, 4, 5, 6 ], [ 1, 3, 7, 8 ], [ 2, 4, 7, 8 ] ] ], 
    vertices := [ [ "A", "A" ], [ "A", "B" ], [ "B", "A" ], [ "B", "B" ] ] )
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(t2,[1],2);|
  [ 1, 3, 5, 6 ]
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(t2,[2],2);|
  [ 2, 4, 5, 6 ]
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(t2,[2,1],2);|
  [ 1, 2, 3, 4 ]
  					
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{SubPolytope}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X857F686C8672E246}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubPolytope({\mdseries\slshape pol, subpol, dim})\index{SubPolytope@\texttt{SubPolytope}}
\label{SubPolytope}
}\hfill{\scriptsize (function)}}\\


 $subpol$ is a list of some $dim$-cells in polytope $pol$. The function returns (the closure of) $subpol$ as a separate polytope. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SubPolytope(t2,[1,2],1);|
  rec( faces := [ [ [ 1, 2 ], [ 1, 2 ] ] ],
    vertices := [ [ "A", "A" ], [ "A", "B" ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ParallelSimplify}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X83D3EDBD86CC8F58}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ParallelSimplify({\mdseries\slshape pol, subpol, dim})\index{ParallelSimplify@\texttt{ParallelSimplify}}
\label{ParallelSimplify}
}\hfill{\scriptsize (function)}}\\


 Polytope $pol$ is simplified using function \texttt{UnionFaces}, along with its subpolytope $subpol$ of dimension $dim$ which is simplified simultaneously. The result is in the form of polytope but
with an additional named list \texttt{.subpol} containing the numbers of $dim$-cells of the simplified polytope that belong to the simplified subpolytope.
The function works only for subpolytopes whose dimension $dim$ is strictly less than the dimension of $pol$. }

 

\subsection{\textcolor{Chapter }{PolMinusFace}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X80512E7E8394ADDB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusFace({\mdseries\slshape pol, adr})\index{PolMinusFace@\texttt{PolMinusFace}}
\label{PolMinusFace}
}\hfill{\scriptsize (function)}}\\


 Cuts out a neighborhood of a face with adress $adr$ from polytope $pol$. In this way, new cells may appear, while some of the old cells are returned
in several copies. The function is organized in such way that the olds cells
retain the same positions in lists $pol$\texttt{.faces[}$i$\texttt{]} and $pol$\texttt{.vertices} as they they had in the input polytope $pol$; for a multiplicated cell, one of its copies stays in that position (while
the other copies are added of course somewhere on the right of the
corresponding list). }

 

\subsection{\textcolor{Chapter }{PolMinusFaceDoublingMethod}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7876CF9E8413B6D6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusFaceDoublingMethod({\mdseries\slshape pol, adr})\index{PolMinusFaceDoublingMethod@\texttt{PolMinusFaceDoublingMethod}}
\label{PolMinusFaceDoublingMethod}
}\hfill{\scriptsize (function)}}\\


 Suppose there is a neighborhood of a $k$-cell $adr$ in a ball complex $pol$ homeomorphic to several $n$-disks $D^n_i$ glued along the cell $adr$. Then, the withdrawal of $adr$ can be performed more economically, namely by creating, for each $n$-disk, its own copy of $adr$. 

 The following simple example deals with a bouquet of line segments glued
together in vertex $adr=[0,1]$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@buket:=rec( vertices := [ 1, 2, 3, 4 ],|
  faces := [ [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ] ] ] );;
  !gapprompt@gap>| !gapinput@PolMinusFaceDoublingMethod(buket,[0,1]);|
  rec( vertices := [ 1, 2, 3, 4, 5, 6 ],
   faces:=[ [ [ 1, 2 ], [ 3, 5 ], [ 4, 6 ] ] ] )
  					
\end{Verbatim}
  }

 

\subsection{\textcolor{Chapter }{PolMinusPol}}
\logpage{[ 2, 1, 6 ]}\nobreak
\hyperdef{L}{X804271D78379B73C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolMinusPol({\mdseries\slshape pol, subpol, dim})\index{PolMinusPol@\texttt{PolMinusPol}}
\label{PolMinusPol}
}\hfill{\scriptsize (function)}}\\


 Cuts out subpolytope $subpol$ of dimension $dim$ from polytope $pol$. As far as possible, the most economical way is chosen for doing this. }

 

\subsection{\textcolor{Chapter }{GlueFaces}}
\logpage{[ 2, 1, 7 ]}\nobreak
\hyperdef{L}{X79DD05937B0FD9D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GlueFaces({\mdseries\slshape pol, pair, dim})\index{GlueFaces@\texttt{GlueFaces}}
\label{GlueFaces}
}\hfill{\scriptsize (function)}}\\


 Glues together two cells in polytope $pol$, \emph{assuming that their boundaries coincide}. The cells have dimension $dim$, and $pair$ is the list of their two numbers. Remark: the function does \emph{not} check whether the cells have indeed the same boundary. Neither does it check
that the result is a valid ball complex. Here is a simple example where the
result is \emph{not} a ball complex: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  gap>d2:=ballAB(2);;
  gap>GlueFaces(d2,[1,2],1);
  rec(faces:=[ [ [1,2] ], [ [1] ] ],
  	vertices:= ["A","B"]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{VerticesRullGlueFace}}
\logpage{[ 2, 1, 8 ]}\nobreak
\hyperdef{L}{X7D9ACC967D3ACE2A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VerticesRullGlueFace({\mdseries\slshape pol, pair, dim})\index{VerticesRullGlueFace@\texttt{VerticesRullGlueFace}}
\label{VerticesRullGlueFace}
}\hfill{\scriptsize (function)}}\\


 Glues together two cells in polytope $pol$. The cells have dimension $dim$, and $pair$ is the list of their two numbers. 

 The function looks at the \emph{names} of vertices of two cells in $pair$, and glues them in such way that the \emph{same-name} vertices are identified. }

 

\subsection{\textcolor{Chapter }{VerticesRullGluePol}}
\logpage{[ 2, 1, 9 ]}\nobreak
\hyperdef{L}{X86C045E57D71AB84}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VerticesRullGluePol({\mdseries\slshape pol, subpol1, subpol2, dim})\index{VerticesRullGluePol@\texttt{VerticesRullGluePol}}
\label{VerticesRullGluePol}
}\hfill{\scriptsize (function)}}\\


 \emph{Identical} subpolytopes $subpol1$ and $subpol2$ of polytope $pol$ and of dimension $dim$ are glued into one. 

 Each of these subpolytopes must have at least one $dim$-cell with at least $dim+1$ vertices and, moreover, be \emph{combinatorial} in the following sense: both this cell and all its subcells must be determined
uniquely by the sets of their vertices. 

 The gluing rules are determined by the \emph{vertex names} in the list $pol$\texttt{.vertices}. The function begins with gluing together the two identical combinatorial $dim$-cells described above, starting with gluing each pair of same-named vertices
into one. Then the process continues inductively on all cells of $subpol1$ and $subpol2$. The presence of the two mentioned identical combinatorial $dim$-cells ensures that the gluing is performed in a unique way. 

 If \emph{two} polytopes are to be glued together by identifying their identical
subpolytopes, then \texttt{FreeUnionPol} can be used first. }

 

\subsection{\textcolor{Chapter }{GlueIndenticalSubpolitops}}
\logpage{[ 2, 1, 10 ]}\nobreak
\hyperdef{L}{X83398A4B7AB2F9D1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GlueIndenticalSubpolitops({\mdseries\slshape pol, sub1, sub2, dim})\index{GlueIndenticalSubpolitops@\texttt{GlueIndenticalSubpolitops}}
\label{GlueIndenticalSubpolitops}
}\hfill{\scriptsize (function)}}\\


 Glues together two identical subpolytopes $sub1$ and $sub2$ of polytope $pol$. Faces with identical indices are identified. ***A more detailed description
is required.*** }

 }

 }

 
\chapter{\textcolor{Chapter }{Immersions and knots}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X79D698DC87F13737}{}
{
 Package \textsf{PL} provides the possibility to work with usual one-dimensional knots and with
two-dimensional knotted surfaces. 
\section{\textcolor{Chapter }{Classical knots}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7C8CDF037A1F8B6C}{}
{
 There are two different ways of describing a knot diagram in package \textsf{PL}. Both of these have their own advantages. 
\subsection{\textcolor{Chapter }{Describing a knot diagram}}\logpage{[ 3, 1, 1 ]}
\hyperdef{L}{X87BA8A577B5E701D}{}
{
 The first way of describing a knot diagram is as follows. Assign a name to
each double point, call these names "generators", choose arbitrarily the
initial point (not being a double point of the diagram) and the positive
direction on the knot. Go along the knot in the positive direction and make
the \emph{word} according to the following rule: at the beginning, the word is empty, then
each double point is written on the right of the word and in the degree $-1$ if we are moving along the underpass, or $1$ if we are moving along the overpass. The word is ready when we have returned
to the initial point. 

 Additionally, each double point has its \emph{orientation}.  If the pair "positive directions of the overpass and underpass" at a double
point determine the positive orientation of the plane, then the orientation is $1$, otherwise $-1$. 

 The mirror image of a knot corresponds to changing all orientations.  

 For the trefoil knot, the simplest diagram yields the word $ac^{-1}ba^{-1}cb^{-1}$, and all orientations are negative. Here is how this diagram is represented
in the package \textsf{PL} library. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Trefoil;|
  rec( kod := [ [ "a", 1 ], [ "c", -1 ], [ "b", 1 ],
                [ "a", -1 ], [ "c", 1 ], [ "b", -1 ] ],
       orient := [ [ "a", -1 ], [ "b", -1 ], [ "c", -1 ] ] )
    				
\end{Verbatim}
 The word and the orientations are thus represented as \texttt{.kod} and \texttt{.orient}, and the example makes it clear how exactly this is done.  

 To describe \emph{links} in this way is slightly more complicated, because the link components must be
identified additionally. For instance, \texttt{TorusKnot(2,4);} produces a two-component \emph{link} as follows: 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@TorusKnot(2,4);|
  rec( 
    kod := rec( 1 := [ [ 1, 1 ], [ 2, -1 ], [ 3, 1 ], [ 4, -1 ] ], 
        2 := [ [ 1, -1 ], [ 2, 1 ], [ 3, -1 ], [ 4, 1 ] ] ), 
    orient := [ [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 4, 1 ] ] )
                  
\end{Verbatim}
  The second way of describing a knot diagram consists in building the ball
complex decomposition of sphere $S^2$ corresponding naturally to the diagram. In this description, the knot goes
along the 1-cells of the complex.  

 The details can be seen on the following example. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  rec(
    1knot :=
      rec(
        dpoints := rec( 1 := [ 6, 1, 3, 4 ], 2 := [ 2, 3, 5, 6 ],
            3 := [ 4, 5, 1, 2 ] ), sheets := [ 1 .. 6 ] ),
    faces := [ [ [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ] ],
        [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 4, 6 ], [ 2, 5 ], [ 3, 6 ] ] ],
    vertices := [ "a", "b", "c" ] )
  			
\end{Verbatim}
 This example shows a trefoil diagram made as a ball complex decomposition of $S^2$ with the additional information concerning the knot itself, and included in
the named list \texttt{.1knot} (meaning "one-dimensional knot", in contrast with knotted 2-surfaces). This
latter contains the list \texttt{.sheets} (remark: the word "sheets" may look a bit strange here, but the point is that
there is also a parallel construction for 2-knots!) of all 1-cells along which
the knot diagram goes, and the named list \texttt{.dpoints} which assigns 4-lists to the names - double point indices. The first two
entries in each of these 4-lists are the indices of two 1-cells forming the
overpass at the double point, while the second two entries are the indices of
two 1-cells forming the underpass.  

 This desription contains redundant information and is not really convenient
for writing it manually looking at a knot diagram. It has, nevertheless, some
advantages. First, it allows to work directly with link diagrams. Second, this
way of description is easily generalized to two-dimensional knotted surfaces,
which will be explained below. }

  

\subsection{\textcolor{Chapter }{Knot1OnSphere2}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7879B1EE80994B6E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Knot1OnSphere2({\mdseries\slshape knot})\index{Knot1OnSphere2@\texttt{Knot1OnSphere2}}
\label{Knot1OnSphere2}
}\hfill{\scriptsize (function)}}\\


 Creates a ball complex decomposition of sphere $S^2$ with all information about the $knot$ diagram, as explained above. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Knot1OnSphere2(Figure8);|
  rec(
    1knot :=
      rec(
        dpoints := rec( 1 := [ 8, 1, 4, 3 ], 2 := [ 4, 5, 8, 7 ],
            3 := [ 2, 3, 5, 6 ], 4 := [ 6, 7, 1, 2 ] ), sheets := [ 1 .. 8 ] ),
    faces :=
      [ [ [ 1, 4 ], [ 3, 4 ], [ 1, 3 ], [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 2, 4 ],
            [ 1, 2 ] ],
        [ [ 1, 3, 6 ], [ 1, 4, 7 ], [ 2, 5, 7 ], [ 2, 6 ], [ 3, 5, 8 ], [ 4, 8 ]
           ] ], vertices := [ "a", "b", "c", "d" ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{KnotInS3}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7A626B2A84CAD77E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KnotInS3({\mdseries\slshape knot})\index{KnotInS3@\texttt{KnotInS3}}
\label{KnotInS3}
}\hfill{\scriptsize (function)}}\\


 Creates a ball complex decomposition of \emph{three}-dimensional sphere $S^3$. The 1-cells along which the $knot$ goes are shown in the named list \texttt{.knot}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@KnotInS3(Figure8);|
  rec( 
    faces := 
      [ [ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ], [ 7, 8 ], [ 1, 7 ], [ 2, 8 ], [ 5, 7 ], 
            [ 6, 8 ], [ 1, 5 ], [ 2, 6 ], [ 1, 3 ], [ 2, 4 ], [ 3, 5 ], 
            [ 4, 6 ], [ 5, 7 ], [ 6, 8 ], [ 3, 7 ], [ 4, 8 ], [ 1, 3 ], 
            [ 2, 4 ], [ 1, 8 ], [ 5, 8 ], [ 2, 5 ], [ 2, 3 ], [ 3, 6 ], 
            [ 6, 7 ], [ 4, 7 ], [ 1, 4 ] ], 
        [ [ 1, 6, 21 ], [ 3, 8, 22 ], [ 1, 9, 23 ], [ 1, 11, 24 ], 
            [ 2, 14, 25 ], [ 3, 15, 26 ], [ 2, 17, 27 ], [ 1, 20, 28 ], 
            [ 5, 11, 17 ], [ 6, 12, 18 ], [ 7, 13, 17 ], [ 8, 14, 18 ], 
            [ 7, 15 ], [ 8, 16 ], [ 9, 13, 19 ], [ 10, 14, 20 ], [ 11, 19 ], 
            [ 12, 20 ], [ 4, 5, 21 ], [ 4, 7, 22 ], [ 3, 10, 23 ], 
            [ 2, 12, 24 ], [ 3, 13, 25 ], [ 4, 16, 26 ], [ 4, 18, 27 ], 
            [ 2, 19, 28 ] ], 
        [ [ 1, 4, 7, 9, 10, 19, 22, 25 ], [ 2, 5, 7, 11, 12, 20, 23, 25 ], 
            [ 2, 6, 13, 14, 20, 24 ], [ 3, 5, 8, 15, 16, 21, 23, 26 ], 
            [ 4, 8, 17, 18, 22, 26 ], 
            [ 1, 3, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 24 ] ] ], 
    knot := [ 21, 22, 23, 24, 25, 26, 27, 28 ], 
    vertices := [ [ "a", "1" ], [ "a", "0" ], [ "b", "1" ], [ "b", "0" ], 
        [ "c", "1" ], [ "c", "0" ], [ "d", "1" ], [ "d", "0" ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Reidemeister10Everywhere}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X7D7395747EC32627}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Reidemeister10Everywhere({\mdseries\slshape knot})\index{Reidemeister10Everywhere@\texttt{Reidemeister10Everywhere}}
\label{Reidemeister10Everywhere}
}\hfill{\scriptsize (function)}}\\


 Checks the $knot$ diagram for presence of free loops that can be removed by the first
Reidemeister move $R^{-1}_0$, and removes them. 

 The numbers $10$ in the function name are because such a Reidemeister takes 1 vertex and
returns (locally) 0 vertices. }

 

\subsection{\textcolor{Chapter }{ZeroLinkFromKnot}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7E710DED7C4E5B3A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeroLinkFromKnot({\mdseries\slshape knot})\index{ZeroLinkFromKnot@\texttt{ZeroLinkFromKnot}}
\label{ZeroLinkFromKnot}
}\hfill{\scriptsize (function)}}\\


 Given a $knot$ diagram, creates a link, adding to $knot$ its copy having zero linking number with it. 

 First, a tubular neighborhood of $knot$ in the three-dimensional space is made. The copy mentioned above is the
projection of $knot$ along the $z$ axis onto the boundary of this tubular neighborhood. }

 

\subsection{\textcolor{Chapter }{KnotGroup}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X797F8D4A848DD9BC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KnotGroup({\mdseries\slshape knot})\index{KnotGroup@\texttt{KnotGroup}}
\label{KnotGroup}
}\hfill{\scriptsize (function)}}\\


 Calculates the knot group, i.e., the fundamental group of the knot complement
in $S^3$. Wirtinger relations are used. }

    

\subsection{\textcolor{Chapter }{TorusKnot}}
\logpage{[ 3, 1, 7 ]}\nobreak
\hyperdef{L}{X7EB8D0A97D7D5E57}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TorusKnot({\mdseries\slshape q, p})\index{TorusKnot@\texttt{TorusKnot}}
\label{TorusKnot}
}\hfill{\scriptsize (function)}}\\


 Creates a diagram of the torus knot $(q,p)$, if $q$ and $p$ are coprime, or otherwise of the corresponding link. Parameter $q > 0$ is the number of threads, while $p$ is the number of revolutions. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@k:=TorusKnot(2,3);|
  rec( kod := [ [ 1, 1 ], [ 2, -1 ], [ 3, 1 ], [ 1, -1 ], [ 2, 1 ], [ 3, -1 ] ],
    orient := [ [ 1, 1 ], [ 2, 1 ], [ 3, 1 ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ZeifertSurface}}
\logpage{[ 3, 1, 8 ]}\nobreak
\hyperdef{L}{X8575EC5C7B564A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeifertSurface({\mdseries\slshape knot})\index{ZeifertSurface@\texttt{ZeifertSurface}}
\label{ZeifertSurface}
}\hfill{\scriptsize (function)}}\\


 Creates a Seifert surface of the $knot$, embedded in the 3-sphere. All 2-cells belonging to the Seifert surface are
listed in the list \texttt{.zeifert}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pol:=ZeifertSurface(Knot7_7);;|
  !gapprompt@gap>| !gapinput@zeif:=SubPolytope(pol, pol.zeifert, 2);;|
  !gapprompt@gap>| !gapinput@PolOrient(zeif);|
  [ 1, 1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1, 1 ]
  					
\end{Verbatim}
 Here we have created a sphere with a Seifert surface in it, then singled out
this Seifert surface as a separate polytope, and checked that this latter is
orientable by constructing an explicit orientation of its 2-cells. }

 

\subsection{\textcolor{Chapter }{ZeifertSurfaceWithSimplyBoundary}}
\logpage{[ 3, 1, 9 ]}\nobreak
\hyperdef{L}{X7D8D06467FBEB8CF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ZeifertSurfaceWithSimplyBoundary({\mdseries\slshape knot})\index{ZeifertSurfaceWithSimplyBoundary@\texttt{ZeifertSurfaceWithSimplyBoundary}}
\label{ZeifertSurfaceWithSimplyBoundary}
}\hfill{\scriptsize (function)}}\\


 Creates a Seifert surface of the $knot$ whose boundary consists of only two 1-cells (and the knot goes, accordinly,
along these two cells). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pol:=ZeifertSurfaceWithSimplyBoundary(Knot7_7);;|
  !gapprompt@gap>| !gapinput@SetOfFacesBoundary(pol,pol.zeifert,2);|
  [ 49, 159 ]
  				
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Knotted surfaces}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7824CA9382EBA957}{}
{
 Here we understand a knotted surface, or surface-knot, as a 2-surface,
connected or not, and embedded in the four-dimensional Euclidean space $\mathbb{R}^4$. Projection $\pi \colon:\; \mathbb{R}^4 \to \mathbb{R}^3$ is \emph{generic} for knotted surface $T$ if the image $\pi (T) $ is $\mathbb{R}^3$ is locally homeomorphic to either (1) 2-disk, (2) two 2-disks intersecting
transversally, (3) three 2-disks intersecting transversally, or (4) Whitney
umbrella. Points having neighborhoods of types (2), (3) or (4) are called \emph{double points}, \emph{triple points}, or \emph{branching points}, respectively. The set of all points (2), (3) and (4) is called \emph{singularity set}. The \emph{diagram} of $T$ is its image $\pi (T)$ together with the information on which sheet is "higher" or "lower" near all
double points, w.r.t. to the projection $\pi$. 
\subsection{\textcolor{Chapter }{Defining knotted surfaces}}\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X780A382580DA1540}{}
{
 By a one-point compactification, we pass from $\mathbb{R}^3$ to the 3-sphere $S^3$. We pepresent a knotted surface $T$ diagram as a ball decomposition of $S^3$ such that all sheets of $T$ lie in its 2-skeleton. All information concerning the diagram within the
polytope is contained in the attached named list \texttt{.2knot}. This list contains, in its turn, named list \texttt{.sheets} where the indiced of all 2-cells are collected belonging to the surface knot,
and named list \texttt{.dpoints} where the names are the double point edges, and to each edge, a four-element
list is attached of the 2-cells lying in the diagram and in the star of this
edge. The first two entries in this list are the 2-cells lying in the upper
sheet, while the two last - the 2-cells lying in the lower sheet. This
information is of course enough to identify also the triple and branching
points. 

  }

 

\subsection{\textcolor{Chapter }{PolSimplifyWith2Knot}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X845EC0BA802775BB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PolSimplifyWith2Knot({\mdseries\slshape pol})\index{PolSimplifyWith2Knot@\texttt{PolSimplifyWith2Knot}}
\label{PolSimplifyWith2Knot}
}\hfill{\scriptsize (function)}}\\


 Simplifies polytope $pol$ containing a knotted surface. Uses function \texttt{UnionFaces} which unites pairs of balls in the polytope. 

 This function, similarly to \texttt{PolSimplify}, does not check whether further simplifications of the obtained polytope are
possible. So, its makes sense to apply this function several times. }

 

\subsection{\textcolor{Chapter }{SingularitySet2Knot}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X859D50D9858D5B25}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SingularitySet2Knot({\mdseries\slshape pol})\index{SingularitySet2Knot@\texttt{SingularitySet2Knot}}
\label{SingularitySet2Knot}
}\hfill{\scriptsize (function)}}\\


 Returns the singularity set, i.e., the double point graph (actually containing
also triple and branching points) for the knotted surfaces diagram which is
supposed to be contained in the record $pol$. The list \texttt{.graf} contains all 1-cells of the ambient polytope $pol$ that enter in the double point graph. Also, there is the named list \texttt{.order} where the names are the indices of vertices, and the corresponding entry
describes the vertex star in the following format. For a triple point, the
first two elements are the "upper" edges - those formed by the intersection of
the upper and the middle sheets; the second two elements are the "middle"
edges - those formed by the intersection of the upper and the lower sheets;
and the last two elements are the "lower" edges - those formed by the
intersection of the middle and the lower sheets. For a double point, the list
contains just two edges, and for a branching point - just one edge. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SingularitySet2Knot(TurnKnot(Trefoil,2));|
  	...
  rec( graf := [ 7, 4, 5, 6, 19, 20, 21, 22, 17, 18, 23, 8, 9, 10, 12, 45, 32,
        31, 25, 26, 51, 54, 55, 64, 112, 113, 114, 115, 134, 136, 137, 138,
        131, 130, 129, 119, 109, 118, 127, 106, 124, 105, 123, 104, 122, 102,
        99, 98, 79, 97, 78, 53, 94, 52, 59, 93, 92, 57, 73, 56, 72, 90, 70, 69,
        68, 67, 66, 65 ],
    order := rec( 1 := [ 137, 92 ], 10 := [ 12, 102 ], 11 := [ 10, 12 ],
        13 := [ 4 ], 14 := [ 22, 17, 19, 20, 104, 97 ],
        15 := [ 19, 18, 21, 22, 105, 98 ], 16 := [ 20, 21, 18, 23, 106, 99 ],
        19 := [ 25 ], 2 := [ 138, 94 ], 20 := [ 32, 31, 25, 26, 109, 102 ],
        21 := [ 23, 26 ], 23 := [ 17, 32 ], 24 := [ 31, 112 ],
        25 := [ 113, 104 ], 26 := [ 114, 105 ], 27 := [ 115, 106 ],
        30 := [ 45, 109 ], 34 := [ 45, 112 ], 36 := [ 113, 118 ],
        37 := [ 115, 119 ], 40 := [ 51, 56, 54, 53, 118, 122 ],
        41 := [ 53, 52, 55, 56, 114, 123 ], 42 := [ 54, 55, 52, 57, 119, 124 ],
        45 := [ 127, 59 ], 46 := [ 59, 57 ], 48 := [ 51 ],
        49 := [ 64, 69, 67, 66, 129, 122 ], 5 := [ 4, 9, 7, 6, 97, 92 ],
        50 := [ 66, 65, 69, 68, 130, 123 ], 51 := [ 68, 67, 70, 65, 131, 124 ],
        54 := [ 72 ], 55 := [ 79, 78, 73, 72, 134, 127 ], 56 := [ 73, 70 ],
        58 := [ 64, 79 ], 59 := [ 136, 78 ], 6 := [ 5, 6, 8, 9, 98, 93 ],
        60 := [ 137, 129 ], 61 := [ 130, 93 ], 62 := [ 138, 131 ],
        64 := [ 134, 90 ], 67 := [ 136, 90 ], 7 := [ 7, 8, 5, 10, 99, 94 ] ) )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{TripleDoubleBranchPoints}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X81D8934B80A7BE6A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TripleDoubleBranchPoints({\mdseries\slshape pol})\index{TripleDoubleBranchPoints@\texttt{TripleDoubleBranchPoints}}
\label{TripleDoubleBranchPoints}
}\hfill{\scriptsize (function)}}\\


 Returns, for a ball complex $pol$ with a knotted surface diagram inside it, a named list (record) containing, in
its turn, named lists \texttt{.triple}, \texttt{.double} and \texttt{.branch} where the names are those polytope vertices which are triple, double or
branching points of the diagram, respectively. In \texttt{.triple}, for each vertex $v$ again a named list is returned, containing the fields \texttt{.u}, \texttt{.m} and \texttt{.d} being the lists of the 2-cells belonging to the upper, middle, and lower
sheets and lying in the star of $v$. In \texttt{.double}, there are only lists \texttt{.u} and \texttt{.d}. As for the named list \texttt{.branch}, it simply returns, for each branching vertex $v$, the list of 2-cells belonging to the knotted surface and lying in the star
of $v$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
   gap> pol:=TurnKnot(Trefoil,1);;
   ...
   gap> TripleDoubleBranchPoints(pol);
  rec( branch := rec( 13 := [ 2, 6, 22, 30 ], 19 := [ 13, 16, 37, 44 ] ),
    double :=
      rec( 1 := rec( d := [ 24, 25, 41, 57 ], u := [ 22, 57, 51, 27 ] ),
        10 := rec( d := [ 28, 37, 38 ], u := [ 2, 30, 7 ] ),
        11 := rec( d := [ 28, 36, 38 ], u := [ 2, 6, 7 ] ),
        2 := rec( d := [ 23, 28, 55, 52, 55 ], u := [ 25, 41, 26 ] ),
        21 := rec( d := [ 36, 38, 43 ], u := [ 8, 12, 14 ] ),
        23 := rec( d := [ 30, 39, 48 ], u := [ 8, 12, 16 ] ),
        24 := rec( d := [ 7, 46, 47 ], u := [ 13, 44, 14 ] ),
        25 := rec( d := [ 24, 40, 41 ], u := [ 27, 39, 51 ] ),
        26 := rec( d := [ 26, 42, 27 ], u := [ 23, 24, 40 ] ),
        27 := rec( d := [ 23, 43, 52 ], u := [ 26, 42, 41 ] ),
        30 := rec( d := [ 47, 48, 51, 57 ], u := [ 19, 44, 20, 43 ] ),
        34 := rec( d := [ 46, 54, 57, 47 ], u := [ 14, 20, 19, 44 ] ) ),
    triple :=
      rec(
        14 := rec( d := [ 32, 33, 40, 41 ], m := [ 27, 30, 35, 39 ],
            u := [ 8, 9, 11, 12 ] ),
        15 := rec( d := [ 27, 34, 35, 42 ], m := [ 23, 31, 32, 40 ],
            u := [ 9, 10, 11, 12 ] ),
        16 := rec( d := [ 23, 31, 36, 43 ], m := [ 33, 34, 41, 42 ],
            u := [ 8, 9, 10, 12 ] ),
        20 := rec( d := [ 37, 38, 43, 44 ], m := [ 7, 30, 47, 48 ],
            u := [ 8, 13, 14, 16 ] ),
        5 := rec( d := [ 24, 25, 32, 33 ], m := [ 22, 27, 30, 35 ],
            u := [ 2, 3, 5, 6 ] ),
        6 := rec( d := [ 26, 27, 34, 35 ], m := [ 23, 24, 31, 32 ],
            u := [ 3, 4, 5, 6 ] ),
        7 := rec( d := [ 23, 28, 31, 36 ], m := [ 25, 26, 33, 34 ],
            u := [ 2, 3, 4, 6 ] ) ) )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsDiagrammOf2Knot}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X8448826B8111EC48}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsDiagrammOf2Knot({\mdseries\slshape pol})\index{IsDiagrammOf2Knot@\texttt{IsDiagrammOf2Knot}}
\label{IsDiagrammOf2Knot}
}\hfill{\scriptsize (function)}}\\


 Check a 2-knot diagram in a 3-manifold. Namely: (1) the correctness of all
references to polytope cells, (2) the double point graph, (3) the absence of
self-osculation points.  
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
   gap> pol:=TurnKnot(Figure8,-1);;
  
    All good!
  
   gap> IsDiagrammOf2Knot(pol);
   true
  					
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{SurfaceOf2Knot}}
\logpage{[ 3, 2, 6 ]}\nobreak
\hyperdef{L}{X870383C87924E495}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SurfaceOf2Knot({\mdseries\slshape M3})\index{SurfaceOf2Knot@\texttt{SurfaceOf2Knot}}
\label{SurfaceOf2Knot}
}\hfill{\scriptsize (function)}}\\


 For a 3-manifold $M^3$ equipped with a knotted surface diagram, the preimage of the surface is
returned, that is, the 2-manifold, where also the preimages of double, triple,
and branching points are indicated. The named list \texttt{.preimages}contains lists \texttt{.1} and \texttt{.0.}. List \texttt{.1} consists of pairs of preimages of double point edges; the first entry is the
edge lying in the lower sheet, and the second entry is the edge lying in the
upper sheet. List \texttt{.0} consists of lists of length either 1 or 3; these are the lists of preimages of
branching and triple points, respectively. For a triple points, the preimages
go in the following order: the vertex on the lower sheet first, then the
middle, and then the upper vertex. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{TurnKnot}}
\logpage{[ 3, 2, 7 ]}\nobreak
\hyperdef{L}{X857BA8697BA2F587}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{TurnKnot({\mdseries\slshape knot, number})\index{TurnKnot@\texttt{TurnKnot}}
\label{TurnKnot}
}\hfill{\scriptsize (function)}}\\


 Returns a diagram, embedded in the 3-sphere $S^3$, of the \emph{twist-spun} 2-knot obtained from the 1-knot diagram $knot$. The $number$ is the number of twists; it can be positive, negative or zero. In the last
case, we get just a spun-diagram. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|TurnKnot(Trefoil,0);B
  I'm trying simplify a polytope.
  
    ...
  
   All good!
  
  rec(
    2knot :=
      rec( dpoints := rec( 11 := [ 12, 7, 9, 10 ], 12 := [ 8, 9, 11, 12 ],
            13 := [ 10, 11, 13, 8 ], 14 := [ 18, 7, 15, 16 ],
            15 := [ 14, 15, 17, 18 ], 16 := [ 16, 17, 13, 14 ] ),
        sheets := [ 7, 8, 14, 9, 15, 10, 16, 11, 17, 12, 18, 13 ] ),
    faces :=
      [ [ [ 2, 3 ], [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2 ], [ 5, 6 ], [ 4, 5 ],
            [ 4, 6 ], [ 5, 6 ], [ 4, 5 ], [ 1, 4 ], [ 2, 5 ], [ 3, 6 ],
            [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ],
        [ [ 1, 3, 5 ], [ 1, 4 ], [ 2, 5 ], [ 6, 8, 10 ], [ 6, 9 ], [ 7, 10 ],
            [ 11, 14 ], [ 1, 6, 12, 13 ], [ 2, 7, 11, 12 ], [ 3, 8, 11, 13 ],
            [ 4, 9, 12, 13 ], [ 5, 10, 11, 12 ], [ 13, 16 ], [ 1, 6, 15, 16 ],
            [ 2, 7, 14, 15 ], [ 3, 8, 14, 16 ], [ 4, 9, 15, 16 ],
            [ 5, 10, 14, 15 ] ],
        [ [ 7, 10, 13, 16 ], [ 1, 4, 8, 10, 12 ], [ 2, 5, 8, 11 ],
            [ 3, 6, 9, 12 ], [ 1, 4, 14, 16, 18 ], [ 2, 5, 14, 17 ],
            [ 3, 6, 15, 18 ] ] ],
    vertices := [ [ 1, "a" ], [ 1, "b" ], [ 1, "c" ], [ 2, "a" ], [ 2, "b" ],
        [ 2, "c" ] ] )
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{2KnotInS4}}
\logpage{[ 3, 2, 8 ]}\nobreak
\hyperdef{L}{X848FEA1F80CF0734}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{2KnotInS4({\mdseries\slshape pol})\index{2KnotInS4@\texttt{2KnotInS4}}
\label{2KnotInS4}
}\hfill{\scriptsize (function)}}\\


 Given a three-dimensional polytope $pol$ with a surface knot $T$ diagram in it, returns an embedding of $T$ into the 4-sphere $S^4$. The result is a ball complex decomposition of $S^4$ with the additional list \texttt{.2knot} containing the 2-faces that form the surface knot. }

 

\subsection{\textcolor{Chapter }{OrientBrockenDiagramm}}
\logpage{[ 3, 2, 9 ]}\nobreak
\hyperdef{L}{X780890177ADEBF2C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OrientBrockenDiagramm({\mdseries\slshape s3})\index{OrientBrockenDiagramm@\texttt{OrientBrockenDiagramm}}
\label{OrientBrockenDiagramm}
}\hfill{\scriptsize (function)}}\\


 Returns a broken diagram for an orientable connected knotted surface. 

 For an orientable 2-knot in 3-sphere $s3$, its broken diagram and double point graph are computed. Returns a named
list, as explained below. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s3:=TurnKnot(Trefoil,2);;|
  !gapprompt@gap>| !gapinput@rez:=OrientBrockenDiagramm(s3);;|
  !gapprompt@gap>| !gapinput@RecNames(date);          |
  [ "images", "preimages", "manifold", "colines", "cosheets", "cofaces", 
    "coorient" ]
  					
\end{Verbatim}
 

 The list \texttt{rez.manifold} contains the preimage of the 2-knot, that is, a 2-manifold. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@RecNames(rez.manifold);  |
  [ "vertices", "faces" ]
  					
\end{Verbatim}
 

 The list \texttt{rez.images} contains the images of the singular points in the 2-knot diagram. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrintObj(rez.images);|
  rec(
    0 := [ 4, 5, 6, 11, 12, 13, 14, 17, 18, 38, 39, 40, 45, 46, 47, 48, 51, 52 
       ],
    1 := [ 7, 4, 5, 6, 19, 20, 21, 22, 24, 16, 17, 18, 8, 9, 10, 11, 25, 54, 
                  . . .
  					
\end{Verbatim}
 The list \texttt{rez.images.0} contains the vertex indices in polytope $s3$ for the triple and branching points. The list \texttt{rez.images.1} contains the edge indices in $s3$ for the double point edges. 

 The list \texttt{rez.preimages} contains the preimages of singular points in the 2-knot diagram. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@PrintObj(rez.preimages);|
  rec(
    0 := [ [ 69, 4, 70 ], [ 71, 5, 72 ], [ 6, 73, 74 ], [ 11 ], 
                  . . .
    1 := [ [ 7, 143 ], [ 4, 144 ], [ 5, 145 ], [ 6, 146 ], [ 19, 147 ], 
                  . . .
  					
\end{Verbatim}
 The list \texttt{rez.preimages.0} contains the indices of the triple and branching points preimages, and the
list \texttt{rez.preimages.1} contains the indices of the double edges. These indices correspond to the
record \texttt{rez.manifold}. The numerations in \texttt{rez.images.i} and \texttt{rez.preimages.i} coincide in the sense that the preimage of element \texttt{rez.images.}$i[k]$ consists of the elements in \texttt{rez.preimages.}$i[k]$. For instance, the preimage of vertex 14 - a triple point - consists of three
points in \texttt{rez.manifold}. Vertex 11 in polytope $s3$ is a branching point in the 2-knot diagram, so we get just one point as its
preimage in polytope \texttt{rez.manifold} 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@pos:=Position(rez.images.0,14);;|
  !gapprompt@gap>| !gapinput@rez.preimages.0[pos];|
  [ 82, 14, 81 ]
  !gapprompt@gap>| !gapinput@pos:=Position(rez.images.0,11);;|
  !gapprompt@gap>| !gapinput@rez.preimages.0[pos];          |
  [ 11 ]
  					
\end{Verbatim}
 And finally, each double edge has exactly two preimages. 

 The singular point graph has the triple and branching points as its vertices,
and the diagram's double edges as its edges. An edge of the singular point
graph may pass through several edges of the ball complex. The singular point
graph edges are numbered in some arbitrary way. The list \texttt{rez.colines} assigns to each $i$-th double edge from \texttt{rez.images.1} the singular point graph edges that passes through it. 

 The list \texttt{rez.cosheets} shows, for an $i$-th 2-cell from \texttt{s3.2knot}, to which 2-cell of the broken diagram it belongs. 

 As it is assumed that the preimage of the 2-knot is orientable, it follows
that the double edges can also be oriented, and orientations can be assigned
to the graph vertices as well. Namely, the direction of a double edge is
positive if it makes a positive vector triple together with the normal vectors
to the corresponding upper and lower sheets. Triple point orientation is the
sign of the triple of the outgoing double edges, and branching point
orientation tells whether the oriented double edge points at or from it. These
orientations are contained in the lists \texttt{rez.coorient.}$dim$, where $dim=0$ or $1$. 

 Note that, as all edges are written as 2-lists of their vertices going in the \emph{increasing} order, the orientation of an edge is written as either $1$ or $-1$ depending on whether or not this increasing order orientation coincides with
the double edge orientation described above. 

 The list \texttt{rez.cofaces.0} contains, in its $i$-th position, the list of double point graph edges that contain the $i$-th vertex of the graph. If this vertex is a triple point, then there are six
such edges. The first three in their list \texttt{rez.cofaces.0[}$i$\texttt{]} are the edges pointing into the $i$th vertex, while the last three point out of the vertex. Moreover, the edges
in the lists \texttt{rez.cofaces.0}, for triple points, are strictly ordered. The 1st and 4th entries are the
upper edges, the 2nd and 5th entries are the middle edges, and the 3rd and 6th
entries are the lower edges. 

 The list \texttt{rez.cofaces.1} gives, for each double point graph edge, the list of three entries, of which
the first is the index of the upper sheet, the second is the index of that
lower sheet that lies in the direction of the positive normal vector to the
upper sheet, and the third is the index of that lower sheet that lies against
the direction of the positive normal vector to the upper sheet. }

 }

 }

 
\chapter{\textcolor{Chapter }{Related structures, auxiliary functions}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X872A6F2A7A3FCCC7}{}
{
 
\section{\textcolor{Chapter }{Some useful lists}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7FF4EDFE7802C632}{}
{
 

\subsection{\textcolor{Chapter }{ConnectedSubset}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7E8931D08158230B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConnectedSubset({\mdseries\slshape list})\index{ConnectedSubset@\texttt{ConnectedSubset}}
\label{ConnectedSubset}
}\hfill{\scriptsize (function)}}\\


 Let $list$ be a list of lists. We say that its entries $list[i]$ and $list[k]$ \emph{can be joined} if there exist such chain of entries $list[i]=list[j_0], list[j_1], \ldots,list[j_n]=list[k]$ where every two neighbors have a non-empty intersection. The function returns
all indiced $i$ of those entries that can be joined with $list[1]$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list:=[[2,3],[4,5],[6,7],[1,4],[2,1]];;|
  !gapprompt@gap>| !gapinput@ConnectedSubset(list);|
  [ 1, 5, 4, 2 ]
  !gapprompt@gap>| !gapinput@ConnectedSubset(T2.faces[1]);|
  [ 1, 4, 5, 8, 2, 6, 3, 7 ]
  					
\end{Verbatim}
 This function is applied to finding the connected components of a manifold,
hence its name. }

 

\subsection{\textcolor{Chapter }{SortCircle}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X81893FB17D432793}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SortCircle({\mdseries\slshape list})\index{SortCircle@\texttt{SortCircle}}
\label{SortCircle}
}\hfill{\scriptsize (function)}}\\


 The input $list$ must consist of two-element lists; these can be thought of as edges of a
graph. The function sorts $list$, assuming that this graph is a cycle. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list:=T2.faces[1]{T2.faces[2][3]};|
  [ [ 2, 3 ], [ 1, 4 ], [ 1, 2 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@SortCircle(list);|
  [ [ 2, 3 ], [ 1, 2 ], [ 1, 4 ], [ 3, 4 ] ]
  !gapprompt@gap>| !gapinput@list;|
  [  ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LineOrdering}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X7906B3DC7F85CC27}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LineOrdering({\mdseries\slshape list})\index{LineOrdering@\texttt{LineOrdering}}
\label{LineOrdering}
}\hfill{\scriptsize (function)}}\\


 The input $list$ must consist of two-element lists; these can be thought of as edges of a
graph. Assuming that the graph is just a chain of $n$ edges joining $n+1$ vertices, the function returns one of the two corresponding linear orderings
of the edges as list \texttt{.order}, and their consistent orientations as \texttt{.orient}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list:=[ [ 2, 3 ], [ 4, 1 ], [ 2, 4 ], [ 15, 1 ], [ 15, 5 ] ];;|
  !gapprompt@gap>| !gapinput@LineOrdering(list);|
  rec( order := [ 5, 4, 2, 3, 1 ], orient := [ 1, -1, 1, -1, 1 ] )
  					
\end{Verbatim}
 If the graph is not such a chain, the fuction finds some (random) subgraph in
it that \emph{is} a chain. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@cycle:=[[1,2],[3,4],[4,2],[1,3]];;|
  !gapprompt@gap>| !gapinput@LineOrdering(cycle);|
  rec( order := [ 3, 1, 4, 2 ], orient := [ 1, -1, 1, 1 ] )
  					
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Rational functions}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X7D0AE6B386CD97BE}{}
{
 Given a polynomial $f$, it can be factored, using the GAP's \texttt{Factors} algorithm, as $f = a f_1^{k_1} \cdots f_n^{k_n}$. We will write such factorization as $[a, f_1, k_1, ... , f_n, k_n]$. The first element in this list is the coefficient $a$, and then each even element is a factor, and each odd element is the
multiplicity of the preceding factor. We call such way of describing a
polynomial RatFunc format. 

 A \emph{rational function} $r$ is represented in RatFunc format as a two-element list. The first element is
its numerator, and the second - its denominator. If one of these elements is
empty, this means that the numerator or denominator is 1. 

\subsection{\textcolor{Chapter }{ConvertPolynomeToRatFunc}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X7C3E05D57A855C98}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertPolynomeToRatFunc({\mdseries\slshape f})\index{ConvertPolynomeToRatFunc@\texttt{ConvertPolynomeToRatFunc}}
\label{ConvertPolynomeToRatFunc}
}\hfill{\scriptsize (function)}}\\


 Converts polynomial $f$ into the RatFunc format. }

 

\subsection{\textcolor{Chapter }{ConvertToRatFunc}}
\logpage{[ 4, 2, 2 ]}\nobreak
\hyperdef{L}{X7A779D807C39FF10}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertToRatFunc({\mdseries\slshape f})\index{ConvertToRatFunc@\texttt{ConvertToRatFunc}}
\label{ConvertToRatFunc}
}\hfill{\scriptsize (function)}}\\


 Converts rational function $f$ into the RatFunc format. }

 

\subsection{\textcolor{Chapter }{ConvertFromRatFuncToPolynom}}
\logpage{[ 4, 2, 3 ]}\nobreak
\hyperdef{L}{X7F0A392F7EC34763}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertFromRatFuncToPolynom({\mdseries\slshape f})\index{ConvertFromRatFuncToPolynom@\texttt{ConvertFromRatFuncToPolynom}}
\label{ConvertFromRatFuncToPolynom}
}\hfill{\scriptsize (function)}}\\


 Converts polynomial $f$ from RatFunc to usual format. }

 

\subsection{\textcolor{Chapter }{ConvertFromRatFunc}}
\logpage{[ 4, 2, 4 ]}\nobreak
\hyperdef{L}{X7DF541D77AED60BA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ConvertFromRatFunc({\mdseries\slshape f})\index{ConvertFromRatFunc@\texttt{ConvertFromRatFunc}}
\label{ConvertFromRatFunc}
}\hfill{\scriptsize (function)}}\\


 Converts rational function $f$ from RatFunc to usual format. }

 

\subsection{\textcolor{Chapter }{SimplifyRatFunc}}
\logpage{[ 4, 2, 5 ]}\nobreak
\hyperdef{L}{X85525EF3795860BC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SimplifyRatFunc({\mdseries\slshape f})\index{SimplifyRatFunc@\texttt{SimplifyRatFunc}}
\label{SimplifyRatFunc}
}\hfill{\scriptsize (function)}}\\


 Simplifies a rational function $f$. It can be given either in the usual or RatFunc format. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(Rationals,"x");;|
  !gapprompt@gap>| !gapinput@y:=Indeterminate(Rationals,"y");;|
  !gapprompt@gap>| !gapinput@f:=(x^2-y^2)/(x+y)^2;;|
  !gapprompt@gap>| !gapinput@f1:=ConvertToRatFunc(f);|
  [ [ 1, x-y, 1, x+y, 1 ], [ 1, x+y, 2 ] ]
  !gapprompt@gap>| !gapinput@SimplifyRatFunc(f1);|
  [ [ 1, x-y, 1 ], [ 1, x+y, 1 ] ]
  					
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@g:=[[2,x-y^2,0],[]];;|
  !gapprompt@gap>| !gapinput@SimplifyRatFunc(g);|
  [ [ 2 ], [ 1 ] ]
  					
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@x:=Indeterminate(GF(2),"x");|
  !gapprompt@gap>| !gapinput@y:=Indeterminate(GF(2),"y");|
  !gapprompt@gap>| !gapinput@z:=Indeterminate(GF(2),"z");|
  !gapprompt@gap>| !gapinput@f:=x^2+y^2+z^2;;|
  !gapprompt@gap>| !gapinput@ConvertToRatFunc(f);|
  [ [ Z(2)^0, x+y+z, 2 ], [ Z(2)^0 ] ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SumRatFunc}}
\logpage{[ 4, 2, 6 ]}\nobreak
\hyperdef{L}{X82E0B0FC7992BA2E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SumRatFunc({\mdseries\slshape f, g})\index{SumRatFunc@\texttt{SumRatFunc}}
\label{SumRatFunc}
}\hfill{\scriptsize (function)}}\\


 Calculates the sum of rational functions $f$ and $g$ given in the RatFunc format. }

 

\subsection{\textcolor{Chapter }{ProdRatFunc}}
\logpage{[ 4, 2, 7 ]}\nobreak
\hyperdef{L}{X7B1F22A07F55E140}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ProdRatFunc({\mdseries\slshape f, g})\index{ProdRatFunc@\texttt{ProdRatFunc}}
\label{ProdRatFunc}
}\hfill{\scriptsize (function)}}\\


 Calculates the product of rational functions $f$ and $g$ given in the RatFunc format. }

 

\subsection{\textcolor{Chapter }{GcdPolynomial}}
\logpage{[ 4, 2, 8 ]}\nobreak
\hyperdef{L}{X8500B73B8429F14B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GcdPolynomial({\mdseries\slshape f, g})\index{GcdPolynomial@\texttt{GcdPolynomial}}
\label{GcdPolynomial}
}\hfill{\scriptsize (function)}}\\


 Calculates the greatest common divisor of polynomials $f$ and $g$. These can be entered either in RatFunc or usual, format; the result is in
RatFunc format. 

 This calculation does not involve the overall coefficients of $f$ and $g$, their gcd must be calculated separately. }

 

\subsection{\textcolor{Chapter }{LcmPolynomial}}
\logpage{[ 4, 2, 9 ]}\nobreak
\hyperdef{L}{X7CC8FF297DA9CF6B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LcmPolynomial({\mdseries\slshape f, g})\index{LcmPolynomial@\texttt{LcmPolynomial}}
\label{LcmPolynomial}
}\hfill{\scriptsize (function)}}\\


 Calculates the least common multiple of polynomials $f$ and $g$. These can be entered either in RatFunc or usual, format; the result is in
RatFunc format. 

 This calculation does not involve the overall coefficients of $f$ and $g$, their lcm must be calculated separately. }

 

\subsection{\textcolor{Chapter }{DerivativePolynomRatFunc}}
\logpage{[ 4, 2, 10 ]}\nobreak
\hyperdef{L}{X81EA09AF878104FB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DerivativePolynomRatFunc({\mdseries\slshape f, x})\index{DerivativePolynomRatFunc@\texttt{DerivativePolynomRatFunc}}
\label{DerivativePolynomRatFunc}
}\hfill{\scriptsize (function)}}\\


 Calculates the derivative of polynomial $f$ given in RatFunc format. }

 

\subsection{\textcolor{Chapter }{DerivativeRatFunc}}
\logpage{[ 4, 2, 11 ]}\nobreak
\hyperdef{L}{X8112D91385A27DB0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DerivativeRatFunc({\mdseries\slshape f, x})\index{DerivativeRatFunc@\texttt{DerivativeRatFunc}}
\label{DerivativeRatFunc}
}\hfill{\scriptsize (function)}}\\


 Calculates the derivative of rational function $f$ given in RatFunc format. }

 

\subsection{\textcolor{Chapter }{JacobiMatRatFunc}}
\logpage{[ 4, 2, 12 ]}\nobreak
\hyperdef{L}{X7F66B38A832B0FBD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{JacobiMatRatFunc({\mdseries\slshape listf, listx})\index{JacobiMatRatFunc@\texttt{JacobiMatRatFunc}}
\label{JacobiMatRatFunc}
}\hfill{\scriptsize (function)}}\\


 For list $listf$ of rational functions, and list $listx$ of variables, the Jacobian matrix is calculated. The data in $listf$ can be given in a mixed format: some entries in the usual, and others in the
RatFunc format. }

 }

 
\section{\textcolor{Chapter }{Matrices}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X812CCAB278643A59}{}
{
 

\subsection{\textcolor{Chapter }{Pfaffian}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7A4302F685FA84A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Pfaffian({\mdseries\slshape mat})\index{Pfaffian@\texttt{Pfaffian}}
\label{Pfaffian}
}\hfill{\scriptsize (function)}}\\


 Calculates the Pfaffian of a skew-symmetric matrix $mat$. Uses an analogue of the Gauss algorithm. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat:=[[0,-3,-1,1],[3,0,-1,2],[1,1,0,3],[-1,-2,-3,0]];;|
  !gapprompt@gap>| !gapinput@PrintArray(mat);|
  [ [   0,  -3,  -1,   1 ],
    [   3,   0,  -1,   2 ],
    [   1,   1,   0,   3 ],
    [  -1,  -2,  -3,   0 ] ]
  !gapprompt@gap>| !gapinput@Pfaffian(mat);|
  -8
  				
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Grassmann algebras}}\logpage{[ 4, 4, 0 ]}
\hyperdef{L}{X7882DD9079FFCDF6}{}
{
 At the moment, we don't have any realization of Grassmann algebra structures
that could allow to declare variables as `Grassmann'. Nevertheless, here is
how we can operate with Grassmann monomials and their sums - arbitrary
Grassmann algebra elements. 

 We assume that all Grassmann variables are numbered. The default ordering of
Grassmann variables is lexicographical: for instance, the result of
multiplication of two Grassmann polynomials (see below) will have its
monomials ordered lexicographically. 

 A Grassmann monomial - product of some Grassmann variables and a scalar - is
represented as a two-element list whose first element is the list of indices
of the Grassmann variables, and whose second element is the scalar (element of
a field, or commutative ring or algebra). 

 A Grassmann algebra element ( = function of Grassmann variables) $f(x_1, x_2, \dots, x_k) = \sum a_{i_1, \ldots, i_s} x_{i_1} \cdots x_{i_s}$ is represented as a named list with two fields $f$\texttt{.monomials} and $f$\texttt{.coeffs}. The first of these contains, at its $j$-th position, a word of Grassmann variables, while the second contains, at the
same position, the coefficient corresponding to this word (that is, \texttt{f.monomials[j]} and \texttt{f.coeffs[j]} describe together one monomial entering in $f$. 

 Note that a monomial may contain \emph{repeated variables}, which would mean its vanishing, of course. Using \texttt{GrassmannProduct} with unity (represented as \texttt{rec(monomials := [[]], coeffs := [1])}) brings a Grassmann polynomial into the canonical form, deleting, in
particular, such monomials.  

\subsection{\textcolor{Chapter }{GrassmannMonomialsProduct}}
\logpage{[ 4, 4, 1 ]}\nobreak
\hyperdef{L}{X860AA41783165689}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmannMonomialsProduct({\mdseries\slshape mon1, mon2})\index{GrassmannMonomialsProduct@\texttt{GrassmannMonomialsProduct}}
\label{GrassmannMonomialsProduct}
}\hfill{\scriptsize (function)}}\\


 Calculate the product of two Grassmann monomials $mon1$ and $mon2$. Here is how this works for the following two products: $ (2\ a_1a_2) * (3\ a_5a_4a_6)=-6\ a_1a_2a_3a_4a_5 a_6$ and $(2\ a_1 a_2) * ( 3\ a_5 a_2 a_6) = 0$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@GrassmannMonomialsProduct([[1,2],2],[[5,4,6],3]);|
  [ [ 1, 2, 4, 5, 6 ], -6 ]
  !gapprompt@gap>| !gapinput@GrassmannMonomialsProduct([[1,2],2],[[5,2,6],3]);|
  [ [  ], 0 ]
  					
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{GrassmannProduct}}
\logpage{[ 4, 4, 2 ]}\nobreak
\hyperdef{L}{X7F3EE70681C3D8C0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmannProduct({\mdseries\slshape f, g})\index{GrassmannProduct@\texttt{GrassmannProduct}}
\label{GrassmannProduct}
}\hfill{\scriptsize (function)}}\\


 Calculates the product of Grassmann algebra elements $f$ and $g$. }

 

\subsection{\textcolor{Chapter }{GrassmannSum}}
\logpage{[ 4, 4, 3 ]}\nobreak
\hyperdef{L}{X79DFD3ED7FDCC6D8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GrassmannSum({\mdseries\slshape f, g})\index{GrassmannSum@\texttt{GrassmannSum}}
\label{GrassmannSum}
}\hfill{\scriptsize (function)}}\\


 Calculates the sum of Grassmann algebra elements $f$ and $g$. }

 

\subsection{\textcolor{Chapter }{BerezinIntegral}}
\logpage{[ 4, 4, 4 ]}\nobreak
\hyperdef{L}{X80094E517830BE72}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BerezinIntegral({\mdseries\slshape f, a})\index{BerezinIntegral@\texttt{BerezinIntegral}}
\label{BerezinIntegral}
}\hfill{\scriptsize (function)}}\\


 Calculates the Berezin integral of function $f$ w.r.t. Grassmann variable (indexed as) $a$. }

 

\subsection{\textcolor{Chapter }{BerezinMultipleIntegral}}
\logpage{[ 4, 4, 5 ]}\nobreak
\hyperdef{L}{X7A3ACABF7E9F9F6D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{BerezinMultipleIntegral({\mdseries\slshape f, list})\index{BerezinMultipleIntegral@\texttt{BerezinMultipleIntegral}}
\label{BerezinMultipleIntegral}
}\hfill{\scriptsize (function)}}\\


 Calculates the multiple Berezin integral of function $f$ w.r.t. those Grassmann variables whose indices are in $list$. The order of integration is determined by the order of variables in $list$. }

  }

 
\section{\textcolor{Chapter }{Four-manifold invariants from hexagon cohomology}}\logpage{[ 4, 5, 0 ]}
\hyperdef{L}{X857C8EEA7D750403}{}
{
 Hexagon cohomologies produce "discrete action densities" for piecewise linear
TQFT's, see \href{https://arxiv.org/abs/1707.02847} {\texttt{https://arxiv.org/abs/1707.02847}}. These action densities are polynomials over a field of finite
characteristic. Currently, this package provides tools for calculating
manifold invariants only in characteristic two, although some functions can
already work in different characteristics. 

\subsection{\textcolor{Chapter }{actionlib}}
\logpage{[ 4, 5, 1 ]}\nobreak
\hyperdef{L}{X87E75A3387308126}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{actionlib\index{actionlib@\texttt{actionlib}}
\label{actionlib}
}\hfill{\scriptsize (global variable)}}\\


 A data structure containing nontrivial discrete action densities for different
characteristics. It consists of lists \texttt{actionlib.}$char.deg$, each containing (some) action densities that are \emph{homogeneous} polynomials of degree $deg$ over the prime field of characteristic $char$. Our discrete action densities are actually actions for a single pentachoron,
and they are written in \texttt{actionlib} for pentachoron 12345 with the standard orientation. 

 The nontriviality of a discrete action density means here that it corresponds
to a nontrivial (not being a coboundary) hexagon cocycle. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@actionlib.2.3[1];|
  rec( coeffs := [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ],
    monoms := [ [ 1, 2, 4 ], [ 1, 3, 4 ], [ 1, 3, 5 ], [ 2, 3, 5 ], [ 2, 4, 5 ] ] )
                  
\end{Verbatim}
 As we see, the action density is represented as a dictionary with keys \texttt{coeffs} and \texttt{monoms}. The list \texttt{.monoms} consists of the monomials, while the list \texttt{.coeffs} consists of their coefficients, making together the polynomial in question.
So, the action density in the above example is $x_1x_2x_4 + x_1x_3x_4 + x_1x_3x_5 + x_2x_3x_5 + x_2x_4x_5$. The variables $x_1,\ldots,x_5$ correspond to the 3-faces of pentachoron 12345, going in the lexicographic
order: 1234, ..., 2345. }

 

\subsection{\textcolor{Chapter }{getLsystem}}
\logpage{[ 4, 5, 2 ]}\nobreak
\hyperdef{L}{X82C5CFFC7A96C163}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{getLsystem({\mdseries\slshape pol, action})\index{getLsystem@\texttt{getLsystem}}
\label{getLsystem}
}\hfill{\scriptsize (function)}}\\


 Produces a simplified form of the action for the whole polytope $pol$ from a given input $action$ for pentachoron $u = 12345$ - i.e., here $action$ is an action density as stored in \texttt{actionlib}. Also, produces the "rough invariant" of the manifold, as introduced in \href{https://arxiv.org/abs/1707.02847} {\texttt{https://arxiv.org/abs/1707.02847}}. 

 The simplified form means the following. The action for the whole polytope is
the sum over all pentachora (with proper signs determined by their
orientations), hence it depends on a humongous lot of variables $x_i$. But actually there exists a huge subspace $W$ in the linear space of all variables $x_i$, such that the action is always constant along $W$, see again the above mentioned paper. This means that the action depends in
fact only on a few linear combinations of $x_i$. 

 So, the result contains field \texttt{.dim} - number of these linear combinations now thought of as independent variables
on which the (polynomial) action depends, field \texttt{.monomes} - the monomials entering in the action, and field \texttt{.coeffs} - their coefficients. There is also field \texttt{.rough{\textunderscore}invariant} containing the "rough invariant" of the manifold. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1:=sphereAB(1);;|
  !gapprompt@gap>| !gapinput@t2:=PolProduct(s1,s1);;|
  !gapprompt@gap>| !gapinput@t4:=PolProduct(t2,t2);; # we made thus a 4-torus|
  !gapprompt@gap>| !gapinput@action := actionlib.2.3[1];;|
  !gapprompt@gap>| !gapinput@t4syst := getLsystem(t4, action);|
  rec( coeffs := [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ],
    dim := 6, monomes := [ [ 1, 1, 6 ], [ 1, 6, 6 ], [ 5, 6, 6 ], [ 5, 5, 6 ],
        [ 2, 2, 5 ], [ 3, 3, 4 ], [ 3, 4, 4 ], [ 2, 5, 5 ] ], rough_invariant := 6 )
                 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{lookover}}
\logpage{[ 4, 5, 3 ]}\nobreak
\hyperdef{L}{X7C239D99842548A1}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{lookover({\mdseries\slshape lsystem, k})\index{lookover@\texttt{lookover}}
\label{lookover}
}\hfill{\scriptsize (function)}}\\


 Here $lsystem$ is a polynomial given by its monomials \texttt{.monomes}, their corresponding coefficients \texttt{.coeffs}, and the number of variables \texttt{.dim}, like produced by the \texttt{getLsystem} command (but \texttt{rough{\textunderscore}invariant} is not needed here). When the variables take all the values in the field of
degree $k$ (note that the characteristic is automatically taken from the polynomial), the
polynomials takes values in the same field with some \emph{frequencies} (numbers of times). 

 The command produces these frequencies for all field elements, written in the
form of a list. The order of corresponding field elements can be seen using
function \texttt{List(field, x -{\textgreater} x)} (exactly this function!). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@lookover(t4syst, 2);|
  [ 2080, 0, 2016, 0 ]
  !gapprompt@gap>| !gapinput@List(GF(4), x -> x);|
  [ 0*Z(2), Z(2^2), Z(2)^0, Z(2^2)^2 ]
                  
\end{Verbatim}
 As we have computed \texttt{t4syst} over the field \texttt{GF(2)}, and we put $k = 2$ in the example, the result contains the frequencies of elements from field \texttt{GF(4)}. }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{PL-manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
