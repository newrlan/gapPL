InstallGlobalFunction( LeftRight,
# ОПИСАНИЕ:
# программы которые вычисляют ребро слева или справа от выбранной точки. Вычисление проводится над заданным узлом.
# входные данные: K -узел, 
#                 indF - индекс 1-грани диаграммы узла относительно которой производим вычисления,
#                 point - имя точки в которой производим вычисления
# выходные данные: индексы 1-граней диаграммы которые лежат слева и справа от точки point.
# зависимости: нет.

# ПРИМЕЧАНИЕ: будем считать, что точка имеет положиельную ориентацию, 
# если переход пересекает проход справа на лево относительно направления прохода,
#             и точка имеет отрицательную ориентацию, если переход пересекает 
# проход слева на право относительно направления прохода.

function(K,indF, point)
     local left,right,s,ind,napr,orientP,t, 1faces,r, n ;

# сперва определяем индекс точки point, т.е. проходим ли мы ее сверху или снизу.
n:=Length(K.kod);
r:=(indF+1)mod n;
if r=0 then r:=n; fi;
1faces:=[K.kod[indF],K.kod[r]];
s:=[1faces[1][1],1faces[2][1]];
ind:=1faces[Position(s,point)][2]; # принимает значения +1 (проходим всерху) или -1 (проходим снизу)

# вычисляем направление 1faces, идет ли оно к точке point или от нее
if Position(s,point)=2 # т.е. мы идем к точке point
   then napr:=1;
   else napr:=-1;
fi;

# вычисляем ориентацию точки point
if [point,1] in K.orient
   then orientP:=1;
   else orientP:=-1;
fi;

# вычисляем, какие ребра лежат по бокам от т.point
t:=Position(K.kod,[point,-ind]); # индекс искомых 1-граней, 
# 1-грань с индексом t выходит из точки point, 1-грань с индексом (t-1) входит в эту точку.

if ind*napr*orientP=1 # эта формула была получена в результате просмотра всех частных случаев (всего их 8).
   then right:=t-1; # слева
        left:=t;   # справа

   else right:=t;
        left:=t-1;
fi;

if right=0 then right:=n; fi;
if left=0 then left:=n; fi;

return rec(left:=left,right:=right);
end );


################################################################################

InstallGlobalFunction( SectionLR,
# ОПИСАНИЕ:
# программы которые вычисляют области слева и справа от заданного ребра
# входные данные: K -узел, 
#                 indF - индекс 1-грани диаграммы узла, относительно которой производим вычисления,
# выходные данные: состав областей слева и справа от указанной 1-грани
# зависимости: LeftRight.g

function(K, indF)
     local n, B, i, sectionL, sectionR, s, t, face,r;

# начальной точкой ребра с индексом indF будет точка K.kod[indF]
n:=Length(K.kod);
r:=(indF+1) mod n;
if r=0 then r:=n; fi;
B:=K.kod[r];
i:=indF;
sectionL:=[]; # первоначально мы не добавляем ребро с индексом indF 
              # в список ограничивающих ребер области слева (справа) от ребра.
sectionR:=[]; # этот индекс добавится когда будет осуществляться цикл while и будет означать конец цикла.

# вычисляем область слева от ребра с индексом indF
s:=0;
while s<1 do
     i:=LeftRight(K,i,B[1]).left; # вычислили ребро слева от ребра indF
     Add(sectionL,i); # добавили его индекс в список ограничивающих ребер области слева от ребра с индексом indF
     if i=indF then s:=s+1; fi;
     t:=(i+1)mod n;
     if t=0 then t:=n; fi;
     face:=[K.kod[i],K.kod[t]];
     B:=Difference(face,[ [B[1],-B[2]] ])[1];
od;

# вычисляем область справа от ребра
# ПРИМЕЧАНИЕ: при совершении полного цикла вычисления области слева от ребра, 
#             переменные i и B принимут исходные значения.
s:=0;
while s<1 do
     i:=LeftRight(K,i,B[1]).right; # вычислили ребро слева от ребра indF
     Add(sectionR,i); # добавили его индекс в список ограничивающих ребер области слева от ребра с индексом indF
     if i=indF then s:=s+1; fi;
     t:=(i+1)mod n;
     if t=0 then t:=n; fi;
     face:=[K.kod[i],K.kod[t]];
     B:=Difference(face,[ [B[1],-B[2]] ])[1];
od;

# циклы для вычисления левой и правой области необходимо производить раздельно, т.к. области могут ограничиваться
# различным количествои ребер.

return rec(sectionL:=sectionL, sectionR:=sectionR);
end );

################################################################################

##  InstallGlobalFunction( Diagonal2,
##  # ОПИСАНИЕ:
##  # программа которая на выбранной 2-грани политопа, добавляет 1-грань.
##  # входные данные: p -политоп, 
##  #                 ind - индекс 2-грани политопа, на которой будет лежать 1-грань,
##  #                 name - имена вершин на которые натягивается грань.
##  # выходные данные: политоп.
##  # зависимости: .g
##  
##  function(p, ind, name)
##       local a,b, Nvert,t1,g,t2,t,IndNvert,NvertPor,l,s,per,t_per,d,i;
##  
##  g:=StructuralCopy(p);
##  # 1) извлечем состав 2-грани ind.
##  t:=StructuralCopy(g.faces[2][ind]);
##  
##  # 2) Добавляем новую грань (диагональ) в конец списка 1-граней
##  a:=Position(p.vertices,name[1]);
##  b:=Position(p.vertices,name[2]);
##  Add(g.faces[1],Set([a,b]));
##  
##  # 3) Восстановим границу 2-грани (окружность) с учетом порядка вершин. 
##  #    а) каждое ребро 2-грани переводим в список вершин на которое оно натянуто.
##  Nvert:=List(t,x->g.vertices{g.faces[1][x]});
##  #    б) производим упорядочение ребер
##  NvertPor:=[Nvert[1]];
##  IndNvert:=[2..Length(Nvert)];
##  l:=1;
##  while IndNvert<>[] do
##       s:=[];
##       for i in IndNvert do
##           if Intersection(NvertPor[l],Nvert[i])<>[] then
##              Add(NvertPor,Nvert[i]);
##              l:=l+1;
##              Add(s,i);
##           fi;
##       od;
##       IndNvert:=Difference(IndNvert,s);
##  od;
##  
##  #    в) меняем порядок 1-граней в соответсвии с изменением порядка в списках Nvert и NvertPor.
##  per:=PermListList(NvertPor,Nvert);  # считаем перестановку
##  t_per:=Permuted(t,per);    # переставляем индексы
##  
##  # 4) Разобьем границу на две части
##  #    а) посчитаем когда встречаются вершины с индексами name
##  s:=1;
##  a:=[];
##  b:=[];
##  for i in NvertPor do
##      if name[1] in i then Add(a,s); fi;
##      if name[2] in i then Add(b,s); fi;
##      s:=s+1;
##  od;
##  
##  #    б) разобьем список t_per на два
##  if Length(UnionSet(a,b))=3 
##    then
##        d:=Intersection(a,b);
##    else 
##        if (a=[1,Length(t)]) or (b=[1,Length(t)])
##          then UniteSet(a,b);
##               d:=[1..a[2]];
##          else UniteSet(a,b);
##               d:=[a[2]..a[3]];
##        fi;
##  fi;
##  t1:=t_per{d};
##  t2:=t_per{Difference([1..Length(t)],d)};
##  
##  #    в) добавим в каждый из списков t1, t2 ссылку на диагональ.
##  Add(t1,Length(g.faces[1]));
##  Add(t2,Length(g.faces[1]));
##  
##  # 5) определяем в какие 3-грани входила измельченая 2 грань. Изменяем состав измельченной 3-грани.
##  #    a) Заменим старую 2-грань ind на t1, добавляеи в конец списка 2-граней грань t2.
##  g.faces[2][ind]:=t1;
##  Add(g.faces[2],t2);
##  
##  #    б) если грань ind входила в состав 3-грани, то добавляем к ее образующим еще и адрес второй грани измельчения.
##  if Length(g.faces)>2 then
##    for i in g.faces[3] do
##       if ind in i then
##          Add(i,Length(g.faces[2]));
##       fi;
##    od;
##  fi;
##  
##  return g;
##  end );

###############################################################################

InstallGlobalFunction( KnotInS3,
# ОПИСАНИЕ:
# программа, которая создает погружение узла в трёхмерный диск.
# входные данные: K1 -узел, 
# выходные данные: разбиение 3-диска на шаровые комплексы, с указанием списка
# ребер по которым проходит узел.

# ПРИМЕЧАНИЕ: будем считать, что точка имеет положительную ориентацию, если
# переход пересекает проход справа налево относительно направления прохода, и
# точка имеет отрицательную ориентацию, если переход пересекает проход слева
# направо относительно направления прохода.

function(K1)
     local n,obl,i,K,D2,s,t,D3,rebra,j,m,k,d,knot,otr, a,b ;

K:=StructuralCopy(K1);
# 1) Предварительные вычисления.
#   a) построим граф узла.
n:=Length(K.kod);
D2:=rec(vertices:=[], faces:=[]);
for i in K.orient do # создание вершин графа
    Add(D2.vertices,i[1]);
od;

D2.faces[1]:=[];
for i in [1..n-1] do # создание ребер графа.
    s:=Position(D2.vertices,K.kod[i][1]);
    t:=Position(D2.vertices,K.kod[i+1][1]);
    D2.faces[1][i]:=[s,t];
od;
s:=Position(D2.vertices,K.kod[n][1]);
t:=Position(D2.vertices,K.kod[1][1]);
D2.faces[1][n]:=[s,t];

#   б) вычислим все области которые ограничивает граф на плоскости.
obl:=[];
for i in [1..n] do
   Add(obl,Set(SectionLR(K,i).sectionL));
   Add(obl,Set(SectionLR(K,i).sectionR));
od;

obl:=Set(obl);

#    в) примечание: если добавить к D2 (графу узла) все области,
# на которые он разбивает плоскость, то мы получим разбиение 2-сферы на шаровые комплексы.
#       Чтобы сделать из этой сферы 2-диск, нужно выкинуть одну из областей (внешнюю). 
# Без ограничения общности можно выкинуть первую область в списке obl. По формуле Эйлера получим,
# что число 2-граней сферы в нашем случае равно 2+n/2 (n/2 это количество двойных точек диаграммы узла).
d:=obl[1];
D2.faces[2]:=obl{[2..(2+n/2)]};

# 2) Создадим диск D3 в которой погрузим узел.
#    а) умножим D2 на отрезок [1,0].
otr:=rec(vertices:=["1","0"],faces:=[[[1,2]]]);
D3:=PolProduct(D2,otr);
#    б) на все внешние 2-грани диска D3 натянем 3-грань.
k:=Length(D3.faces[2]);
m:=Length(D2.faces[1])+1;
UniteSet(d,[m,m+1..k]);
Add(D3.faces[3],d);

# 3) погружаем узел в диск D3. Каждое ребро на диаграмме узла лежит на
# соотверствующей 2-грани диска D3 (которые когда-то были 1-гранями диска D2).
#    а) создаем списки имен вершин которые соединяются диагоналями(по которым
#    проходит узел).
rebra:=[];
for i in [1..n-1] do
    rebra[i]:=StructuralCopy([K.kod[i],K.kod[i+1]]);
od;
rebra[n]:=StructuralCopy([K.kod[n],K.kod[1]]);

#    б) переименновываем вершины
for i in [1..n] do
    for j in [1,2] do
       if rebra[i][j][2]=1 then
          rebra[i][j][2]:="1";
        else rebra[i][j][2]:="0";
       fi;
    od;
od;

#    в) вычисляем индексы 1-граней по которым будет проходить узел
knot:=[1..n]+Length(D3.faces[1]);

#    г) добавляем диагонали на соответсвующих 2-гранях.
for i in [1..n] do
	a:=Position(D3.vertices,rebra[i][1]);
	b:=Position(D3.vertices,rebra[i][2]);
	D3:=DivideFace(D3,[2,i],[a,b]);
##     D3:=Diagonal2(D3,i,rebra[i]);
od;

D3.knot:=knot; # если это действие выполнить на шаге 3.в), то информация knot потеряется

return D3;
end );

###############################################################################

